<?xml version="1.0"?>
<package>
<?component error="false" debug="false"?>
<comment>
///////////////////////////////////////////////////////////////////////////////////////////////
//
// Weather Script Component
//
// Copyright (c) 2009, Julien Templier
// All rights reserved.
//
///////////////////////////////////////////////////////////////////////////////////////////////
// * $LastChangedRevision$
// * $LastChangedDate$
// * $LastChangedBy$
///////////////////////////////////////////////////////////////////////////////////////////////
// 
// Redistribution and use in source and binary forms, with or without modification, are
// permitted provided that the following conditions are met:
//	1. Redistributions of source code must retain the above copyright notice, this list of
//		 conditions and the following disclaimer. 
//	2. Redistributions in binary form must reproduce the above copyright notice, this list
//		 of conditions and the following disclaimer in the documentation and/or other materials
//		 provided with the distribution. 
//	3. The name of the author may not be used to endorse or promote products derived from this
//		 software without specific prior written permission. 
//
//	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//	OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
//	MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
//	COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
//	EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
//	GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
//	ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
//	OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
//	POSSIBILITY OF SUCH DAMAGE.
//
///////////////////////////////////////////////////////////////////////////////////////////////
</comment>

<component id="WeatherController">
	<comment>
	Main weather controller
	</comment>
	<registration description="Weather Controller"
      			  progid="DXWeather.Controller"
      			  version="1"
      	    	  classid="{2DB557E8-FA03-40ce-B559-D0BCCFCB48CC}"/>  
      	    	  
	<object id="m_providers" 	progid="Scripting.Dictionary" />  
	<object id="m_providerList" progid="Scripting.Dictionary" /> 
	
	<public>
		<comment>
			Unit system in use
			
			Default is metric system. Set to False to use the English/Imperial unit system.
		</comment>
		<property name="UseMetricSystem">
			<get />
			<put />
		</property>
		
		<comment>
			Setup the license
			  - id: partner id
			  - key: license key
			  
			returns: E_OK if the license was set properly
					 E_INVALIDLICENSE if license information is missing
					 E_ERROR if no provider has been set
					 
			You can use that method to check whether the current provider needs license information.
			
			Ex: Try calling the method first with empty information: SetLicense("", ""). If you get E_OK,
			no license information is needed, otherwise, you need to provide some license information.
			You can check if id, key or both are needed in the same way.
		</comment>
		<method name="SetLicense">
			<parameter name="id" />
			<parameter name="key" />
		</method>
		
		<comment>
			Returns a dictionnary of available providers (key = provider id, value = provider name)
		</comment>
		<property name="Providers">
			<get />
		</property>
		
		<comment>
			Set the provider to use
			  - id: provider id (key) as retrieved bu GetProviders
			  
			returns: E_OK if the provider was set correctly
				     E_ERROR if the id is not a valid provider id (the current provider will be reset to Nothing)
		</comment>
		<method name="SetProvider">
			<parameter name="id" />
		</method>
	
		<comment>
			Register callbacks for weather controller calls
			  - locationCallback(WeatherLocation[] locations)
			  		called when new location results are available
			  		
			  - weatherCallback(WeatherInfo weather)
			  		called when new weather information is available
			  		
			  - alertsCallback(WeatherAlert[] alerts)
			  		called when new alert information is available
			  		
			  - forecastCallback(WeatherInfo[] forecast)
			  		called when new forecast information is available
			  		
			  - camerasCallback(WeatherCamera[] cameras)
			  		called when new camera results are available
			  		
			  - errorCallback(int errorCode, string errorMessage)
			  		called when an error is raised during an operation						  
		</comment>
		<method name="RegisterCallbacks">
			<parameter name="locationCallback" />
			<parameter name="weatherCallback" />
			<parameter name="alertsCallback" />
			<parameter name="forecastCallback" />
			<parameter name="camerasCallback" />
			<parameter name="errorCallback" />
		</method>
		
		<comment>
			Get a WeatherLocation object to be used in a query
		</comment>
		<method name="GetQueryObject" />

		<comment>
			Get a list of locations.
			  - locationQuery: a WeatherLocation object with the proper fields set
			  
			returns: E_OK if the request was send					 
					 E_NOTAVAILABLE if the query type is not supported by the current provider
					 E_INVALIDLICENSE if license information is missing
					 E_ERROR if no provider has been set
		</comment>
		<method name="GetLocations">
			<parameter name="locationQuery" />
		</method>
		
		<comment>
			Get the current weather
			  - locationQuery: a WeatherLocation object with the proper fields set
			 			 		 (this can be a WeatherLocation object returned by GetLocations)
			  
			returns: E_OK if the request was send
					 E_NOTIMPLEMENTED if this function is not implemented for the current provider
					 E_NOTAVAILABLE if the query type is not supported by the current provider
					 E_INVALIDLICENSE if license information is missing
					 E_ERROR if no provider has been set
		</comment>
		<method name="GetWeather">
			<parameter name="locationQuery" />
		</method>
		
		<comment>
			Get a list of alerts
			  - locationQuery: a WeatherLocation object with the proper fields set
			  					 (this can be a WeatherLocation object returned by GetLocations)
			  
			returns: E_OK if the request was send
					 E_NOTIMPLEMENTED if this function is not implemented for the current provider
					 E_NOTAVAILABLE if the query type is not supported by the current provider	
					 E_INVALIDLICENSE if license information is missing
					 E_ERROR if no provider has been set		  
		</comment>
		<method name="GetAlerts">
			<parameter name="locationQuery" />
		</method>
		
		<comment>
			Get the forecast
			  - locationQuery: a WeatherLocation object with the proper fields set
							    (this can be a WeatherLocation object returned by GetLocations)
			  
			returns: E_OK if the request was send
					 E_NOTIMPLEMENTED if this function is not implemented for the current provider
					 E_NOTAVAILABLE if the query type is not supported by the current provider
					 E_INVALIDLICENSE if license information is missing
					 E_ERROR if no provider has been set			  
		</comment>
		<method name="GetForecast">
			<parameter name="locationQuery" />
		</method>
		
		<comment>
			Get a list of cameras.
			  - locationQuery: a WeatherLocation object with the proper fields set
			  					 (this can be a WeatherLocation object returned by GetLocations)
			  
			returns: E_OK if the request was send
					 E_NOTIMPLEMENTED if this function is not implemented for the current provider
					 E_NOTAVAILABLE if the query type is not supported by the current provider	
					 E_INVALIDLICENSE if license information is missing
					 E_ERROR if no provider has been set		  
		</comment>
		<method name="GetCameras">
			<parameter name="locationQuery" />
		</method>
		
		<comment>
			Abort any operation that is in progress
			  
			returns: E_OK if the function succeeded	
					 E_ERROR if no provider has been set		  
		</comment>
		<method name="Abort" />
		
		<comment>
			Add a new provider
			  - id: provider id
			  - provider: provider script component instance
			  
			This is targeted to developers, allowing them to develop a new weather provider without having to modify this file
			  
			returns: E_OK if the provider was added correctly
				     E_ERROR if the id already exists
		</comment>
		<method name="AddProvider">
			<parameter name="provider" />
		</method>
	</public>
	
	<script language="JScript">
	<![CDATA[
	
	//**Start Encode**	
	
	// Error
	var ErrorCode = createComponent("WeatherError");
	
	// Callbacks
	var m_locationsCallback = null;
	var m_weatherCallback = null;
	var m_alertsCallback = null;
	var m_forecastCallback = null;
	var m_camerasCallback = null;
	var m_errorCallback = null;
	
	// Current provider
	var m_currentProvider = null;
	var m_useMetricSystem = true;
	
	// License information
	var m_id = "";
	var m_key = "";
	
	Init();
	
	/////////////////////////////////////////////////////////////////////////////////////////
	// Provider registration
	function Init() {				
		AddProvider(createComponent("WUnderground"));
		AddProvider(createComponent("TWC"));
		AddProvider(createComponent("NOAA"));
	}	

	/*=============================================================================================================================
	=
	= Public Methods
	=
	=============================================================================================================================*/
	
	// Get the unit system in use
	function get_UseMetricSystem() {
		return m_useMetricSystem;
	}
	
	function put_UseMetricSystem(system) {
		m_useMetricSystem = system;
		
		// Update the provider
		if (m_currentProvider != null)
			m_currentProvider.UseMetricSystem = m_useMetricSystem;		
	}
	
	// Get the list of available providers
	function get_Providers() {
		return m_providerList;
	}
	
	// Setup license
	function SetLicense(id, key) {
		m_id = id;
		m_key = key;
		
		// Update license information
		if (m_currentProvider == null)
			return ErrorCode.E_ERROR;
		
		return m_currentProvider.SetLicense(m_id, m_key);		
	}
	
	// Set the provider to use
	function SetProvider(id) {
		if (!m_providers.Exists(id)) {
			// Reset the current provider
			m_currentProvider = null;
			
			return ErrorCode.E_ERROR;
		}
		
		m_currentProvider = m_providers.Item(id);
		m_currentProvider.UseMetricSystem = m_useMetricSystem;
		m_currentProvider.SetLicense(m_id, m_key);
		
		// Register callbacks
		// we have to do that and duplicate all the registration code in all providers,
		// since we cannot use events without registering the component
		m_currentProvider.RegisterCallbacks(OnLocations,
											OnWeather,
											OnAlerts,
											OnForecast,
											OnCameras,
											OnError);
		
		return ErrorCode.E_OK;
	}
	
	// Set the callbacks
	function RegisterCallbacks(locationsCallback, weatherCallback, alertsCallback, forecastCallback, camerasCallback, errorCallback) {
		m_locationsCallback = locationsCallback;
		m_weatherCallback 	= weatherCallback;
		m_alertsCallback 	= alertsCallback;
		m_forecastCallback  = forecastCallback;
		m_camerasCallback   = camerasCallback;
		m_errorCallback 	= errorCallback;
	}
	
	// Add provider to provider list
	function AddProvider(provider) {			
		// Add the new provider to the internal provider list
		m_providers.Add(provider.ID, provider);
		
		// we use a separate provider list to not expose the providers directly to the user script
		m_providerList.Add(provider.ID, provider.Name);
		
		return ErrorCode.E_OK;
	}
	
	// Abort any call in progress
	function Abort() {
		if (m_currentProvider == null)		
			return ErrorCode.E_ERROR;
		
		m_currentProvider.Abort();
	
		return ErrorCode.E_OK;
	}	
	
	// Get a WeatherLocation object
	function GetQueryObject() {
		return createComponent("WeatherLocation");
	}
	
	// Get a WeatherHelper object
	function GetHelper() {
		return m_helperObject;
	}
	
	// Get a list of locations
	function GetLocations(locationQuery) {
		if (m_currentProvider == null)		
			return ErrorCode.E_ERROR;
		
		locationQuery.TrimValues();
		return m_currentProvider.GetLocations(locationQuery);
	}
	
	// Get the current weather
	function GetWeather(locationQuery) {
		if (m_currentProvider == null)		
			return ErrorCode.E_ERROR;
		
		locationQuery.TrimValues();
		return m_currentProvider.GetWeather(locationQuery);
	}
	
	// Get a list of alerts
	function GetAlerts(locationQuery) {
		if (m_currentProvider == null)		
			return ErrorCode.E_ERROR;
		
		locationQuery.TrimValues();
		return m_currentProvider.GetAlerts(locationQuery);
	}
	
	// Get the forecast
	function GetForecast(locationQuery) {
		if (m_currentProvider == null)		
			return ErrorCode.E_ERROR;
		
		locationQuery.TrimValues();
		return m_currentProvider.GetForecast(locationQuery);
	}
	
	// Get a list of cameras
	function GetCameras(locationQuery) {
		if (m_currentProvider == null)		
			return ErrorCode.E_ERROR;
		
		locationQuery.TrimValues();
		return m_currentProvider.GetCameras(locationQuery);
	}	

	/*=============================================================================================================================
	=
	= Callbacks
	=
	=============================================================================================================================*/
	
	// We check here if the callback are defined, so we can call them without checking if they exist in each provider

	function OnLocations(locations) {
		if (m_locationsCallback != null)
			m_locationsCallback(locations);
	}
	
	function OnWeather(weather) {
		if (m_weatherCallback != null)
			m_weatherCallback(weather);
	}
	
	function OnAlerts(alerts) {
		if (m_alertsCallback != null)
			m_alertsCallback(alerts);
	}
	
	function OnForecast(forecast) {
		if (m_forecastCallback != null)
			m_forecastCallback(forecast);
	}
	
	function OnCameras(cameras) {
		if (m_camerasCallback != null)
			m_camerasCallback(cameras);
	}
	
	function OnError(code, value) {
		if (m_errorCallback != null)
			m_errorCallback(code, value);
	}	
		
	]]>
	</script>

</component>

<component id="WeatherError">
	<comment>
	Weather error codes
	</comment>
	<registration description="Weather Error codes"
      			  progid="DXWeather.Error"
      			  version="1"
      	    	  classid="{20AAB6F5-77DB-414e-8469-5D57441BFD19}"/>  
      	    	        	    
	<public>
		<property name="E_OK">
			<get />
		</property>
		
		<property name="E_ERROR">
			<get />
		</property>
		
		<property name="E_NOTAVAILABLE">
			<get />
		</property>
		
		<property name="E_NOTIMPLEMENTED">
			<get />
		</property>
		
		<property name="E_INVALIDLICENSE">
			<get />
		</property>
		
		<property name="E_PARSEERROR">
			<get />
		</property>
		
		
	</public>
	
	<script language="JScript">
	<![CDATA[
	
	//**Start Encode**
	
	// Constants
	var E_OK 			 = 1;
	var E_ERROR 		 = 0;
	var E_NOTAVAILABLE   = -1;
	var E_NOTIMPLEMENTED = -2;
	var E_INVALIDLICENSE = -3;
	var E_PARSEERROR	 = -4;
	
	function get_E_OK()
	{
		return E_OK;
	}
	
	function get_E_ERROR()
	{
		return E_ERROR;
	}
	
	function get_E_NOTAVAILABLE()
	{
		return E_NOTAVAILABLE;
	}
	
	function get_E_NOTIMPLEMENTED()
	{
		return E_NOTIMPLEMENTED;
	}
	
	function get_E_INVALIDLICENSE()
	{
		return E_INVALIDLICENSE;
	}
	
	function get_E_PARSEERROR()
	{
		return E_PARSEERROR;
	}
	
	]]>
	</script>

</component>

<component id="WeatherInfo">
	<comment>
	Weather information
	</comment>
	<registration description="Weather Information"
      			  progid="DXWeather.Info"
      			  version="1"
      	    	  classid="{30EC2AE5-702A-4b2d-94BB-6CE09B399931}"/>  
      	    	      
	<public>
		<comment>
			Constants
		</comment>
		<property name="DAY_PART_DAY">
			<get/>
		</property>
		<property name="DAY_PART_NIGHT">
			<get/>
		</property>	
	
		<comment>
			Weather location info (WeatherLocation object)
		</comment>
		<property name="Location" 				internalname="m_location" />
		
		<comment>
			Weather station name
		</comment>
		<property name="Station" 				internalname="m_station" />
		
		<comment>
			Weather station type
		</comment>
		<property name="Type" 					internalname="m_type" />
		
		<comment>
			Weather info links (WeatherLinks object)
		</comment>
		<property name="Links" 					internalname="m_links" />
		
		<property name="Description"	 		internalname="m_description" />
		<property name="Code" 					internalname="m_code" />
		
		<property name="Date" 					internalname="m_date" />
		
		<property name="Temperature" 			internalname="m_temperature" />
		<property name="TemperatureFeel" 		internalname="m_temperatureFeel" />
		
		<property name="Humidity" 				internalname="m_humidity" />
		
		<property name="Precipitation1H" 		internalname="m_precipitation_1h" />
		<property name="PrecipitationToday" 	internalname="m_precipitation_today" />

		<property name="Visibility" 			internalname="m_visibility" />
		
		<property name="WindDescription" 		internalname="m_windDescription" />
		<property name="WindDirection" 			internalname="m_windDirection" />
		<property name="WindDegrees" 			internalname="m_windDegrees" />
		<property name="WindSpeed" 				internalname="m_windSpeed" />
		<property name="WindGust" 				internalname="m_windGust" />

		<property name="WindChillDescription" 	internalname="m_windChillDescription" />
		<property name="WindChill" 				internalname="m_windChill" />
		
		<property name="Pressure" 				internalname="m_pressure" />
		<property name="PressureTrend"			internalname="m_pressure" />
				
		<property name="DewPointDescription" 	internalname="m_dewPointDescription" />
		<property name="DewPoint" 				internalname="m_dewPoint" />
				
		<property name="HeatDescription" 		internalname="m_heatDescription" />
		<property name="HeatIndex" 				internalname="m_heatIndex" />	
		
		<property name="SolarRadiation" 		internalname="m_solarRadiation" />
		<property name="UV" 					internalname="m_UV" />	
		<property name="UVDescription"			internalname="m_UVDescription" />	
		
		<property name="Sunrise" 				internalname="m_sunrise" />
		<property name="Sunset"					internalname="m_sunset" />
		
		<property name="MoonPhaseDescription" 	internalname="m_moonPhaseDescription" />
		<property name="MoonPhaseCode" 			internalname="m_moonPhaseCode" />
		<property name="MoonIlluminated" 		internalname="m_moonIlluminated" />
		<property name="MoonAge" 				internalname="m_moonAge" />
		
		<property name="DayOfWeek" 				internalname="m_dayOfWeek" />
		<property name="DayPart" 				internalname="m_dayPart" />	
		
		<property name="ForecastDescription" 	internalname="m_forecastDescription" />		
		<property name="ForecastHigh"			internalname="m_forecastHigh" />		
		<property name="ForecastLow" 			internalname="m_forecastLow" />
		
		<property name="UseMetricSystem" 		internalName="m_useMetricSystem" />
		
		
		<comment>
			Time when this object was retrieved (used for caching purposes)
		</comment>
		<property name="LastUpdateTime" 		internalName="m_lastUpdateTime" />
		
		<method name="ToString" />
		
	</public>
	
	<script language="JScript">
	<![CDATA[
	
	//**Start Encode**
	
	/*********************************
	 * Properties
	 *********************************/	
	var DAY_PART_DAY = 0;
	var DAY_PART_NIGHT = 1;
	
	function get_DAY_PART_DAY()
	{
		return DAY_PART_DAY;
	}
	
	function get_DAY_PART_NIGHT()
	{
		return DAY_PART_NIGHT;
	}
	
	var m_useMetricSystem = true;

	
	// Weather data	
	var m_location = null;	
	var m_links    = null;		
			
	var m_station = "";
	var m_type = "";
	
	var m_description = "";
	var m_code = "";

	var m_temperature = "";
	var m_temperatureFeel = "";
	
	var m_humidity = "";
	var m_precipitation_1h = "";
	var m_precipitation_today = "";

	var m_visibility = "";
	
	var m_windDescription = "";
	var m_windDirection = "";
	var m_windDegrees = "";
	var m_windSpeed = "";
	var m_windGust = "";

	var m_windChillDescription = "";
	var m_windChill = "";
	
	var m_pressure = "";
	var m_pressureTrend = "";
			
	var m_dewPointDescription = "";
	var m_dewPoint = "";
			
	var m_heatDescription = "";
	var m_heatIndex = "";
	
	var m_solarRadiation = "";
	var m_UV = "";
	var m_UVDescription = "";
	
	var m_sunrise = "";
	var m_sunset = "";
	
	var m_moonPhaseDescription = "";
	var m_moonPhaseCode = "";
	var m_moonIlluminated = "";
	var m_moonAge = "";
	
	var m_dayOfWeek = "";
	var m_dayPart = "";
	var m_date = "";
	
	var m_forecastDescription = "";
	var m_forecastCode = "";
	var m_forecastHigh = "";	
	var m_forecastLow = "";
	
	var m_lastUpdateTime = "";
	
	/*********************************
	 * Functions
	 *********************************/
	function ToString()
	{
		var text = "";
		
		if (m_location != null)
			text += m_location.ToString();
		
		if (text != "")
			 text += "\n";	
		
		// Station name & type
		text += append("Station", m_station);
		text += append("Type", m_type);
		
		// Description
		text += append("Description", m_description);
		text += append("Code", m_code);
			
		// Date & Time
		if (m_date != null)
			text += append("Date", m_date.toISOString());
			
		// Temperature / Humidity / Precipitation / Visibility
		text += append("Temperature", m_temperature);
		text += append("Temperature (Feel)", m_temperatureFeel);
		text += append("Humidity", m_humidity);
		text += append("Precipitation (1h)", m_precipitation_1h);			
		text += append("Precipitation (today)", m_precipitation_today);			
		text += append("Visibility", m_visibility);
		
		// Wind
		text += append("Wind Description", m_windDescription);
		text += append("Direction", m_windDirection);
		text += append("Degrees", m_windDegrees);
		text += append("Speed", m_windSpeed);
		text += append("Gust", m_windGust);
		text += append("WindChill Description", m_windChillDescription);
		text += append("Chill", m_windChill);
		
		// Pressure / Dew Point / Heat
		text += append("Pressure", m_pressure);
		text += append("Pressure Trend", m_pressure);
		text += append("DewPoint Description", m_dewPointDescription);
		text += append("DewPoint", m_dewPoint);
		text += append("Heat Description", m_heatDescription);
		text += append("Heat Index", m_heatIndex);
		
		// Solar Radiation & UV
		text += append("Solar Radiation", m_solarRadiation);
		text += append("UV Description", m_UVDescription);	
		text += append("UV", m_UV);		
		
		text += append("Day of week", m_dayOfWeek);
		text += append("Day part", m_dayPart);
		
		text += append("Forecast", m_forecastDescription);
		text += append("High", m_forecastHigh);
		text += append("Low", m_forecastLow);
		
		// Sunrise / Sunset / Moon / Day
		text += append("Sunrise", m_sunrise);
		text += append("Sunset", m_sunset);
		text += append("Moonphase", m_moonPhaseDescription);
		text += append("Moon Code", m_moonPhaseCode);
		text += append("Moon Illumination", m_moonIlluminated);
		text += append("Moon Age", m_moonAge);
		
		if (m_links != null) {
			var links = m_links.ToString();
		
			if (links != "")
				text += "\n" + links;			 
		}
							
		return text;
	}
	
	function append(title, value)
	{
		if (value == null || value == "")
			return "";
			
		return title + ": " + value + "\n";
	}
	
	]]>
	</script>

</component>

<component id="WeatherAlert">
	<comment>
	Weather alert container
	</comment>
	<registration description="Weather alert"
      			  progid="DXWeather.Alert"
      			  version="1"
      	    	  classid="{D4F984BF-A90A-45da-A695-ACBD974B9924}"/>    
      	    
	<public>
		<property name="Type" internalname="m_type" />
		<property name="Description" internalname="m_description" />
		<property name="Date" internalname="m_date" />
		<property name="Expiration" internalname="m_expiration" />
		<property name="Message" internalname="m_message" />
		<property name="Phenomena" internalname="m_phenomena" />
		<property name="Significance" internalname="m_significance" />		
		
		<method name="ToString" />
	</public>
	
	<script language="JScript">
	<![CDATA[
	
	//**Start Encode**
	
	var m_type = "";
	var m_description = "";
	var m_date = "";
	var m_expiration = "";
	var m_message = "";
	var m_phenomena = "";
	var m_significance = "";
	
	function ToString()
	{
		var text = m_description + " (" + m_type + ")" + "\n";		
		text += "Date: " + m_date + "\n";
		text += "Expiration: " + m_expiration + "\n";
		text += "Phenomena: " + m_phenomena + "\n";
		text += "Significance: " + m_significance + "\n";
		text += "Message: " + m_message + "\n";
		
		return text;
	}
	
	]]>
	</script>

</component>

<component id="WeatherLocation">
	<comment>
	Weather location/query container
	</comment>
	<registration description="Weather Location"
      			  progid="DXWeather.Location"
      			  version="1"
      	    	  classid="{BC017AA1-3732-4d88-89EC-68823C27ECD3}"/>  
      	    	   
	<public>
		<property name="ID" internalname="m_ID" />		
		<property name="Name" internalname="m_name" />
	
		<property name="Country" internalname="m_country" />		
		<property name="State" internalname="m_state" />
		<property name="City" internalname="m_city" />
		
		<property name="Timezone" internalname="m_timezone" />
		
		<property name="Latitude" internalname="m_latitude" />
		<property name="Longitude" internalname="m_longitude" />
		<property name="Elevation" internalname="m_elevation" />
		
		<property name="Distance" internalname="m_distance" />	
		
		<property name="AirportCode" internalname="m_airportCode" />
		<property name="ZipCode" internalname="m_zipCode" />		
		<property name="CityCode" internalname="m_cityCode" />
		
		<property name="CustomQueryString" internalname="m_customQueryString" />	
				
		<method name="TrimValues" />
		<method name="ToString" />
	</public>
	
	<script language="JScript">
	<![CDATA[
	
	//**Start Encode**
	
	// TODO add function to check if a string is a US zip code
    
	var m_ID = "";

	var m_country = "";
	var m_state = "";
	var m_city = "";
	
	var m_latitude = "";
	var m_longitude = "";
	
	var m_airportCode = "";
	var m_zipCode = "";
	var m_cityCode = "";
	
	var m_customQueryString = "";
	
	// Results-only data
	var m_name = "";
	var m_timezone = "";
	var m_elevation = "";
	var m_distance = "";

	// Trim values used in query
	function TrimValues()
	{
		// Helper
		var m_helper = createComponent("WeatherHelper");
		
		m_ID = m_helper.Trim(m_ID);		
			
		m_country = m_helper.Trim(m_country);
		m_state = m_helper.Trim(m_state);
		m_city = m_helper.Trim(m_city);
		
		m_latitude = m_helper.Trim(m_latitude);
		m_longitude = m_helper.Trim(m_longitude);
		
		m_airportCode = m_helper.Trim(m_airportCode);
		m_zipCode = m_helper.Trim(m_zipCode);
		m_cityCode = m_helper.Trim(m_cityCode);
		
		m_customQueryString = m_helper.Trim(m_customQueryString);				
	}
	
	function ToString()
	{
		var text = "";
		
		if (m_ID != "")
			text += "ID: " + m_ID + "\n";
			
		if (m_name != "")
			text += "Name: " + m_name + "\n";;
		
		// City	
		if (m_city != "" || m_state != "" || m_country !="") {
			text += "City: " + m_city;
			
			if (m_state != "")
				text += ", " + m_state;
				 
			if (m_country != "")
				text += " (" + m_country + ")"
				
			text += "\n";
		}
		
		// Coordinates
		if (m_latitude != "" || m_longitude != "")
			text += "Coordinates: " + m_latitude + ", " + m_longitude + "\n";
			
		// Distance & Elevation
		if (m_distance != "")
			text += "Distance: " + m_distance + "\n";
			
		if (m_elevation != "")
			text += "Elevation: " + m_elevation + "\n";
						
		// Codes
		if (m_zipCode != "")
			text += "Zipcode: " + m_zipCode + "\n";
			
		if (m_airportCode != "")
			text += "Airport: " + m_airportCode + "\n";
			
		if (m_cityCode != "")
			text += "City Code: " + m_cityCode + "\n";
			
		if (m_customQueryString != "")
			text += "Custom: " + m_customQueryString + "\n";

		return text;
	}

	]]>
	</script>

</component>

<component id="WeatherLinks">
	<comment>
	Weather links container
		- current				
		- forecast
		- history
		- credit
		- misc.
	</comment>
	<registration description="Weather Links"
      			  progid="DXWeather.Links"
      			  version="1"
      	    	  classid="{ABD6A877-1597-4b60-AF0E-DD1D1CEA7683}"/>  
      	    	  
    <object id="m_promo" 	progid="Scripting.Dictionary" />   	    	  
      	    
	<public>
		<property name="Current" 		internalname="m_current" />
		<property name="Forecast" 		internalname="m_forecast" />
		<property name="History" 		internalname="m_history" />
		<property name="Credit" 		internalname="m_credit" />
		<property name="Logo" 			internalname="m_logo" />

		<property name="Promo" 			internalname="m_promo" />		
		
		<method name="ToString" />
	</public>
	
	<script language="JScript">
	<![CDATA[
	
	//**Start Encode**
	
	var m_current = "";
	var m_forecast = "";
	var m_history = "";
	var m_credit = "";
	var m_logo = "";	
	
	function ToString()
	{
		var text = "";
		
		if (m_current != "")
			text += "Current: " + m_current + "\n";
			
		if (m_forecast != "")
			text += "Forecast: " + m_forecast + "\n";
			
		if (m_history != "")
			text += "History: " + m_history + "\n";
		
		if (m_credit != "")
			text += "Credit: " + m_credit + "\n";
			
		if (m_logo != "")
			text += "Logo: " + m_logo + "\n";
			
		if (m_promo.Count != 0) {
			text += "Promo links:\n\n";
			
			var keys = (new VBArray(m_promo.Keys())).toArray();
			var items = (new VBArray(m_promo.Items())).toArray();
			
			for (i in keys)
				text += keys[i] + " (" + items[i] + ")" + "\n";			
		}
			
		return text;
	}
	
	]]>
	</script>

</component>

<component id="WeatherHelper">
	<comment>
	Weather Helper functions
	</comment>
	<registration description="Weather Helper"
      			  progid="DXWeather.Helper"
      			  version="1"
      	    	  classid="{4FBA62F1-7479-42e2-84F1-8DE0927C0DAE}"/>  
      	    	  	    
	<public>
		
		<comment>
			Convert from C to F (with rounding)
		</comment>
		<method name="CtoF">
			<parameter name="temperature" />
		</method>
		
		<comment>
			Convert from F to C (with rounding)
		</comment>
		<method name="FtoC">
			<parameter name="temperature" />
		</method>
			
		<comment>
			Convert from meter to feet (with rounding)
		</comment>
		<method name="MtoFT">
			<parameter name="length" />
		</method>
		
		<comment>
			Convert from feet to meter (with rounding)
		</comment>
		<method name="FTtoM">
			<parameter name="length" />
		</method>
		
		<comment>
			Convert from kilometers to miles (with rounding)
		</comment>
		<method name="KMtoMI">
			<parameter name="distance" />
		</method>
		
		<comment>
			Convert from miles to kilometers (with rounding)
		</comment>
		<method name="MItoKM">
			<parameter name="distance" />
		</method>
		
		<comment>
			Convert from millibars to inches of mercury (with rounding)
		</comment>
		<method name="MBtoIN">
			<parameter name="pressure" />
		</method>
		
		<comment>
			Convert from inches of mercury to millibars (with rounding)
		</comment>
		<method name="INtoMB">
			<parameter name="pressure" />
		</method>
		
		<comment>
			Convert from millimeters to inches (with rounding)
		</comment>
		<method name="MMtoIN">
			<parameter name="length" />
		</method>
		
		<comment>
			Convert from inches to millimeters (with rounding)
		</comment>
		<method name="INtoMM">
			<parameter name="length" />
		</method>
		
		<comment>
			Convert from km/h to mp/h (with rounding)
		</comment>
		<method name="KMHtoMPH">
			<parameter name="speed" />
		</method>
		
		<comment>
			Convert from mp/h to km/h (with rounding)
		</comment>
		<method name="MPHtoKMH">
			<parameter name="speed" />
		</method>
		
		<comment>
			Remove multiple, leading or trailing spaces
		</comment>
		<method name="Trim">
			<parameter name="s" />
		</method>
		
		<comment>
			Remove all spaces
		</comment>
		<method name="RemoveSpaces">
			<parameter name="s" />
		</method>
		
		<comment>
			Check XmlDom object for parsing errors and report them
		</comment>
		<method name="CheckParserError">
			<parameter name="request" />
			<parameter name="callback" />
			<parameter name="ErrorCode" />
		</method>
		
		<comment>
			Try to get a node value and return "" if the node doesn't exists
		</comment>
		<method name="GetNodeValue">
			<parameter name="entry" />
			<parameter name="nodeName" />
		</method>
		
		<comment>
			Check a cache for value using the passed refresh rate
			
			returns true if an object is in the cache and up to date
					false otherwise
		</comment>
		<method name="CheckCache">
			<parameter name="cache" />
			<parameter name="id" />
			<parameter name="rate" />
		</method>

	</public>
	
	<script language="JScript">
	<![CDATA[
	
	//**Start Encode**
	
	/////////////////////////////////////////////////////////////////////////////////////////////
	//
	// Misc
	//
	/////////////////////////////////////////////////////////////////////////////////////////////	
	
	function CheckCache(cache, id, rate)
	{
		// check if item exists in the cache
		if (!cache.Exists(id))
			return false;
			
		// Get item last update time
		var updateTime = cache.Item(id).LastUpdateTime;
		
		if (updateTime == null || updateTime == "")
			return false;
		
		// Check if we are past the refresh time
		var now = updateTime.clone().setTimeToNow();
		var refresh = updateTime.clone().addMinutes(rate);
		
		// Hmm, something is wrong here!
		if (now.isBefore(updateTime))
			return false;
			
		// the cache has expired
		if (now.isAfter(refresh))
			return false;
			
		return true;		
	}
	
	/////////////////////////////////////////////////////////////////////////////////////////////
	//
	// Parsing & XML handling
	//
	/////////////////////////////////////////////////////////////////////////////////////////////
	
	// Check the request for parser errors
	function CheckParserError(request, callback, ErrorCode) {

		if (request.parseError.errorCode == 0)
			return true;
		
		if (request.text == "")
			callback(ErrorCode.E_ERROR, "Received empty response!");
		else {	
			var error = "Error parsing response xml: Error " + request.parseError.errorCode + ": " + request.parseError.reason;
			error += "/ Line " + request.parseError.line + " - position " + request.parseError.linepos;
			error += "/ Source: " + escape(request.parseError.srcText);
		
			callback(ErrorCode.E_PARSEERROR, error);
		}
		
		return false;
	}
	
	// Try to get a node value and return "" if the node doesn't exists
	function GetNodeValue(entry, nodeName)
	{
		 var node = entry.selectNodes(nodeName);
		 
		 if (node.length == 0)
		 	return "";
		 	
		 return node[0].nodeValue;
	}
	
	/////////////////////////////////////////////////////////////////////////////////////////////
	//
	// Unit conversion
	//
	/////////////////////////////////////////////////////////////////////////////////////////////
	
	function CtoF(temperature)
	{
		return FormatNumber((9/5) * temperature + 32, 1);
	}
	
	function FtoC(temperature)
	{
		return FormatNumber((5/9) * (temperature - 32) , 1);
	}
	
	function MtoFT(length)
	{
		return FormatNumber(length * 3.280839895013123, 0);
	}
	
	function FTtoM(length)
	{
		return FormatNumber(length * 0.3048, 0);
	}
	
	function KMtoMI(distance)
	{
		return FormatNumber(distance * 0.621371192237334, 1);
	}
	
	function MItoKM(distance)
	{
		return FormatNumber(distance * 1.609344, 1);
	}
	
	function MBtoIN(pressure)
	{
		return FormatNumber(pressure * 0.0295300, 2);
	}
	
	function INtoMB(pressure)
	{
		return FormatNumber(pressure * 33.8639, 2);
	}
	
	function MMtoIN(length)
	{
		return FormatNumber(length * 0.0393700787401575, 2);
	}
	
	function INtoMM(length)
	{
		return FormatNumber(length * 25.4, 2);
	}
	
	function KMHtoMPH(speed)
	{
		return FormatNumber(speed * 0.621371192237334, 1);
	}
	
	function MPHtoKMH(speed)
	{
		return FormatNumber(speed * 1.609344, 1);
	}	
	
	/////////////////////////////////////////////////////////////////////////////////////////////
	//
	// Text manipulation
	//
	/////////////////////////////////////////////////////////////////////////////////////////////	
	
	// Remove multiple, leading or trailing spaces
	function Trim(s) {
		s = s.replace(/(^\s*)|(\s*$)/gi,"");
		s = s.replace(/[ ]{2,}/gi," ");
		s = s.replace(/\n /,"\n");
		return s;
	}
	
	// Remove all spaces
	function RemoveSpaces(s) {
		return s.replace(/(\s|\n)+/g,'');
	}
		
	]]>
	</script>

</component>

<component id="DateEx">
	<comment>
      Dates Component
	</comment>
	<registration description="DateEx Component" progid="DXScriptLibrary.DateEx" version="1" classid="{62C1598A-803B-4525-83D3-654DCD7D72F8}" />  
      	    	   
	<public>
	
		<comment>
			Get a Date object (locale will default to en-US)
		</comment>
		<method name="GetDate" />
		
		<comment>
			Get a Date object of the specified locale
		</comment>
		<method name="GetDateI18N">
			<parameter name="locale" />			
		</method>
		
		<comment>
			Parse a RFC822 date
		</comment>
		<method name="FromRFC822">
			<parameter name="rfc822" />			
		</method>
	
		<comment>
			Convert an epoch to a Date object
		</comment>
		<method name="FromEpoch">
			<parameter name="epoch" />			
		</method>

	</public>
	
	<script language="JScript">
	<![CDATA[
	
	//**Start Encode**
	
	// Return a new Date object
	function GetDate()
	{
		return GetDateI18N("en-US");
	}
	
	// Return a new Date object using the specified locale
	function GetDateI18N(locale)
	{
		// TODO implement on-the-fly loading of a different locale
		return new Date();
	}
	
	// Return a Date from an epoch
	function FromEpoch(epoch)
	{
		return new Date(epoch * 1000);
	}
	
	// Return a Date from an epoch
	function FromRFC822(rfc822)
	{		
		return GetDate().parseExact(rfc822, "ddd, dd MMMM yyyy HH:mm:ss T");
	}
	
	////////////////////////////////////////////////////////////////////////////////////
	// DateJS code
	////////////////////////////////////////////////////////////////////////////////////
	
	// Version: 1.0 SVN
 	// Revision: 194

// #region ************************      Default Locale (en-US)      ************************ 	
	
	Date.CultureInfo = {
		/* Culture Name */
	    name: "en-US",
	    englishName: "English (United States)",
	    nativeName: "English (United States)",
	    
	    /* Day Name Strings */
	    dayNames: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
	    abbreviatedDayNames: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
	    shortestDayNames: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
	    firstLetterDayNames: ["S", "M", "T", "W", "T", "F", "S"],
	    
	    /* Month Name Strings */
	    monthNames: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
	    abbreviatedMonthNames: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
	
		/* AM/PM Designators */
	    amDesignator: "AM",
	    pmDesignator: "PM",
	
	    firstDayOfWeek: 0,
	    twoDigitYearMax: 2029,
	    
	    /**
	     * The dateElementOrder is based on the order of the 
	     * format specifiers in the formatPatterns.DatePattern. 
	     *
	     * Example:
	     <pre>
	     shortDatePattern    dateElementOrder
	     ------------------  ---------------- 
	     "M/d/yyyy"          "mdy"
	     "dd/MM/yyyy"        "dmy"
	     "yyyy-MM-dd"        "ymd"
	     </pre>
	     *
	     * The correct dateElementOrder is required by the parser to
	     * determine the expected order of the date elements in the
	     * string being parsed.
	     */
	    dateElementOrder: "mdy",
	    
	    /* Standard date and time format patterns */
	    formatPatterns: {
	        shortDate: "M/d/yyyy",
	        longDate: "dddd, MMMM dd, yyyy",
	        shortTime: "h:mm tt",
	        shortTimeWithTimeZone: "h:mm tt Z",
	        longTime: "h:mm:ss tt",
	        fullDateTime: "dddd, MMMM dd, yyyy h:mm:ss tt",
	        sortableDateTime: "yyyy-MM-ddTHH:mm:ss",
	        universalSortableDateTime: "yyyy-MM-dd HH:mm:ssZ",
	        rfc1123: "ddd, dd MMM yyyy HH:mm:ss GMT",
	        rfc822: "ddd, dd MMMM yyyy HH:mm:ss GMT",
	        monthDay: "MMMM dd",
	        yearMonth: "MMMM, yyyy"
	    },
	
	    /**
	     * NOTE: If a string format is not parsing correctly, but
	     * you would expect it parse, the problem likely lies below. 
	     * 
	     * The following regex patterns control most of the string matching
	     * within the parser.
	     * 
	     * The Month name and Day name patterns were automatically generated
	     * and in general should be (mostly) correct. 
	     *
	     * Beyond the month and day name patterns are natural language strings.
	     * Example: "next", "today", "months"
	     *
	     * These natural language string may NOT be correct for this culture. 
	     * If they are not correct, please translate and edit this file
	     * providing the correct regular expression pattern. 
	     *
	     * If you modify this file, please post your revised CultureInfo file
	     * to the Datejs Forum located at http://www.datejs.com/forums/.
	     *
	     * Please mark the subject of the post with [CultureInfo]. Example:
	     *    Subject: [CultureInfo] Translated "da-DK" Danish(Denmark)
	     * 
	     * We will add the modified patterns to the master source files.
	     *
	     * As well, please review the list of "Future Strings" section below. 
	     */	
	    regexPatterns: {
	        jan: /^jan(uary)?/i,
	        feb: /^feb(ruary)?/i,
	        mar: /^mar(ch)?/i,
	        apr: /^apr(il)?/i,
	        may: /^may/i,
	        jun: /^jun(e)?/i,
	        jul: /^jul(y)?/i,
	        aug: /^aug(ust)?/i,
	        sep: /^sep(t(ember)?)?/i,
	        oct: /^oct(ober)?/i,
	        nov: /^nov(ember)?/i,
	        dec: /^dec(ember)?/i,
	
	        sun: /^su(n(day)?)?/i,
	        mon: /^mo(n(day)?)?/i,
	        tue: /^tu(e(s(day)?)?)?/i,
	        wed: /^we(d(nesday)?)?/i,
	        thu: /^th(u(r(s(day)?)?)?)?/i,
	        fri: /^fr(i(day)?)?/i,
	        sat: /^sa(t(urday)?)?/i,
	
	        future: /^next/i,
	        past: /^last|past|prev(ious)?/i,
	        add: /^(\+|aft(er)?|from|hence)/i,
	        subtract: /^(\-|bef(ore)?|ago)/i,
	        
	        yesterday: /^yes(terday)?/i,
	        today: /^t(od(ay)?)?/i,
	        tomorrow: /^tom(orrow)?/i,
	        now: /^n(ow)?/i,
	        
	        millisecond: /^ms|milli(second)?s?/i,
	        second: /^sec(ond)?s?/i,
	        minute: /^mn|min(ute)?s?/i,
			hour: /^h(our)?s?/i,
			week: /^w(eek)?s?/i,
	        month: /^m(onth)?s?/i,
	        day: /^d(ay)?s?/i,
	        year: /^y(ear)?s?/i,
			
	        shortMeridian: /^(a|p)/i,
	        longMeridian: /^(a\.?m?\.?|p\.?m?\.?)/i,
	        timezone: /^((e(s|d)t|c(s|d)t|m(s|d)t|p(s|d)t)|((gmt)?\s*(\+|\-)\s*\d\d\d\d?)|gmt|utc)/i,
	        ordinalSuffix: /^\s*(st|nd|rd|th)/i,
	        timeContext: /^\s*(\:|a(?!u|p)|p)/i
	    },
	
		timezones: [{name:"UTC", offset:"-000"}, {name:"GMT", offset:"-000"}, {name:"EST", offset:"-0500"}, {name:"EDT", offset:"-0400"}, {name:"CST", offset:"-0600"}, {name:"CDT", offset:"-0500"}, {name:"MST", offset:"-0700"}, {name:"MDT", offset:"-0600"}, {name:"PST", offset:"-0800"}, {name:"PDT", offset:"-0700"}]
	};	
	
// #endregion	

// #region *********************************      Core      *********************************

	(function () {
	    var $D = Date, 
	        $P = $D.prototype, 
	        $C = $D.CultureInfo,
	        p = function (s, l) {
	            if (!l) {
	                l = 2;
	            }
	            return ("000" + s).slice(l * -1);
	        };
	            
	    /**
	     * Resets the time of this Date object to 12:00 AM (00:00), which is the start of the day.
	     * @param {Boolean}  .clone() this date instance before clearing Time
	     * @return {Date}    this
	     */
	    $P.clearTime = function () {
	        this.setHours(0);
	        this.setMinutes(0);
	        this.setSeconds(0);
	        this.setMilliseconds(0);
	        return this;
	    };
	
	    /**
	     * Resets the time of this Date object to the current time ('now').
	     * @return {Date}    this
	     */
	    $P.setTimeToNow = function () {
	        var n = new Date();
	        this.setHours(n.getHours());
	        this.setMinutes(n.getMinutes());
	        this.setSeconds(n.getSeconds());
	        this.setMilliseconds(n.getMilliseconds());
	        return this;
	    };
	
	    /** 
	     * Gets a date that is set to the current date. The time is set to the start of the day (00:00 or 12:00 AM).
	     * @return {Date}    The current date.
	     */
	    $P.today = function () {
	        return new Date().prototype.clearTime();
	    };
	
	    /**
	     * Compares the first date to the second date and returns an number indication of their relative values.  
	     * @param {Date}     First Date object to compare [Required].
	     * @param {Date}     Second Date object to compare to [Required].
	     * @return {Number}  -1 = date1 is lessthan date2. 0 = values are equal. 1 = date1 is greaterthan date2.
	     */
	    $P.compare = function (date1, date2) {
	        if (isNaN(date1) || isNaN(date2)) { 
	            throw new Error(date1 + " - " + date2); 
	        } else if (date1 instanceof Date && date2 instanceof Date) {
	            return (date1 < date2) ? -1 : (date1 > date2) ? 1 : 0;
	        } else { 
	            throw new TypeError(date1 + " - " + date2); 
	        }
	    };
	    
	    /**
	     * Compares the first Date object to the second Date object and returns true if they are equal.  
	     * @param {Date}     First Date object to compare [Required]
	     * @param {Date}     Second Date object to compare to [Required]
	     * @return {Boolean} true if dates are equal. false if they are not equal.
	     */
	    $P.equals = function (date1, date2) { 
	        return (date1.compareTo(date2) === 0); 
	    };
	
	    /**
	     * Gets the day number (0-6) if given a CultureInfo specific string which is a valid dayName, abbreviatedDayName or shortestDayName (two char).
	     * @param {String}   The name of the day (eg. "Monday, "Mon", "tuesday", "tue", "We", "we").
	     * @return {Number}  The day number
	     */
	    $P.getDayNumberFromName = function (name) {
	        var n = $C.dayNames, m = $C.abbreviatedDayNames, o = $C.shortestDayNames, s = name.toLowerCase();
	        for (var i = 0; i < n.length; i++) { 
	            if (n[i].toLowerCase() == s || m[i].toLowerCase() == s || o[i].toLowerCase() == s) { 
	                return i; 
	            }
	        }
	        return -1;  
	    };
	    
	    /**
	     * Gets the month number (0-11) if given a Culture Info specific string which is a valid monthName or abbreviatedMonthName.
	     * @param {String}   The name of the month (eg. "February, "Feb", "october", "oct").
	     * @return {Number}  The day number
	     */
	    $P.getMonthNumberFromName = function (name) {
	        var n = $C.monthNames, m = $C.abbreviatedMonthNames, s = name.toLowerCase();
	        for (var i = 0; i < n.length; i++) {
	            if (n[i].toLowerCase() == s || m[i].toLowerCase() == s) { 
	                return i; 
	            }
	        }
	        return -1;
	    };
	
	    /**
	     * Determines if the current date instance is within a LeapYear.
	     * @param {Number}   The year.
	     * @return {Boolean} true if date is within a LeapYear, otherwise false.
	     */
	    $P.isLeapYear = function (year) { 
	        return ((year % 4 === 0 && year % 100 !== 0) || year % 400 === 0); 
	    };
	
	    /**
	     * Gets the number of days in the month, given a year and month value. Automatically corrects for LeapYear.
	     * @param {Number}   The year.
	     * @param {Number}   The month (0-11).
	     * @return {Number}  The number of days in the month.
	     */
	    $P.getDaysInMonth = function (year, month) {
	        return [31, ($P.isLeapYear(year) ? 29 : 28), 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][month];
	    };
	 
	    $P.getTimezoneAbbreviation = function (offset) {
	        var z = $C.timezones, p;
	        for (var i = 0; i < z.length; i++) {
	            if (z[i].offset === offset) {
	                return z[i].name;
	            }
	        }
	        return null;
	    };
	    
	    $P.getTimezoneOffset = function (name) {
	        var z = $C.timezones, p;
	        for (var i = 0; i < z.length; i++) {
	            if (z[i].name === name.toUpperCase()) {
	                return z[i].offset;
	            }
	        }
	        return null;
	    };
	
	    /**
	     * Returns a new Date object that is an exact date and time copy of the original instance.
	     * @return {Date}    A new Date instance
	     */
	    $P.clone = function () {
	        return new Date(this.getTime()); 
	    };
	
	    /**
	     * Compares this instance to a Date object and returns an number indication of their relative values.  
	     * @param {Date}     Date object to compare [Required]
	     * @return {Number}  -1 = this is lessthan date. 0 = values are equal. 1 = this is greaterthan date.
	     */
	    $P.compareTo = function (date) {
	        return $P.compare(this, date);
	    };
	
	    /**
	     * Compares this instance to another Date object and returns true if they are equal.  
	     * @param {Date}     Date object to compare. If no date to compare, new Date() [now] is used.
	     * @return {Boolean} true if dates are equal. false if they are not equal.
	     */
	    $P.equals = function (date) {
	        return Date.equals(this, date || new Date());
	    };
	
	    /**
	     * Determines if this instance is between a range of two dates or equal to either the start or end dates.
	     * @param {Date}     Start of range [Required]
	     * @param {Date}     End of range [Required]
	     * @return {Boolean} true is this is between or equal to the start and end dates, else false
	     */
	    $P.between = function (start, end) {
	        return this.getTime() >= start.getTime() && this.getTime() <= end.getTime();
	    };
	
	    /**
	     * Determines if this date occurs after the date to compare to.
	     * @param {Date}     Date object to compare. If no date to compare, new Date() ("now") is used.
	     * @return {Boolean} true if this date instance is greater than the date to compare to (or "now"), otherwise false.
	     */
	    $P.isAfter = function (date) {
	        return this.compareTo(date || new Date()) === 1;
	    };
	
	    /**
	     * Determines if this date occurs before the date to compare to.
	     * @param {Date}     Date object to compare. If no date to compare, new Date() ("now") is used.
	     * @return {Boolean} true if this date instance is less than the date to compare to (or "now").
	     */
	    $P.isBefore = function (date) {
	        return (this.compareTo(date || new Date()) === -1);
	    };
	
	    /**
	     * Determines if the current Date instance occurs today.
	     * @return {Boolean} true if this date instance is 'today', otherwise false.
	     */
	    
	    /**
	     * Determines if the current Date instance occurs on the same Date as the supplied 'date'. 
	     * If no 'date' to compare to is provided, the current Date instance is compared to 'today'. 
	     * @param {date}     Date object to compare. If no date to compare, the current Date ("now") is used.
	     * @return {Boolean} true if this Date instance occurs on the same Day as the supplied 'date'.
	     */
	    $P.isToday = $P.isSameDay = function (date) {
	        return this.clone().clearTime().equals((date || new Date()).clone().clearTime());
	    };
	    
	    /**
	     * Adds the specified number of milliseconds to this instance. 
	     * @param {Number}   The number of milliseconds to add. The number can be positive or negative [Required]
	     * @return {Date}    this
	     */
	    $P.addMilliseconds = function (value) {
	        this.setMilliseconds(this.getMilliseconds() + value * 1);
	        return this;
	    };
	
	    /**
	     * Adds the specified number of seconds to this instance. 
	     * @param {Number}   The number of seconds to add. The number can be positive or negative [Required]
	     * @return {Date}    this
	     */
	    $P.addSeconds = function (value) { 
	        return this.addMilliseconds(value * 1000); 
	    };
	
	    /**
	     * Adds the specified number of seconds to this instance. 
	     * @param {Number}   The number of seconds to add. The number can be positive or negative [Required]
	     * @return {Date}    this
	     */
	    $P.addMinutes = function (value) { 
	        return this.addMilliseconds(value * 60000); /* 60*1000 */
	    };
	
	    /**
	     * Adds the specified number of hours to this instance. 
	     * @param {Number}   The number of hours to add. The number can be positive or negative [Required]
	     * @return {Date}    this
	     */
	    $P.addHours = function (value) { 
	        return this.addMilliseconds(value * 3600000); /* 60*60*1000 */
	    };
	
	    /**
	     * Adds the specified number of days to this instance. 
	     * @param {Number}   The number of days to add. The number can be positive or negative [Required]
	     * @return {Date}    this
	     */
	    $P.addDays = function (value) {
	        this.setDate(this.getDate() + value * 1);
	        return this;
	    };
	
	    /**
	     * Adds the specified number of weeks to this instance. 
	     * @param {Number}   The number of weeks to add. The number can be positive or negative [Required]
	     * @return {Date}    this
	     */
	    $P.addWeeks = function (value) { 
	        return this.addDays(value * 7);
	    };
	
	    /**
	     * Adds the specified number of months to this instance. 
	     * @param {Number}   The number of months to add. The number can be positive or negative [Required]
	     * @return {Date}    this
	     */
	    $P.addMonths = function (value) {
	        var n = this.getDate();
	        this.setDate(1);
	        this.setMonth(this.getMonth() + value * 1);
	        this.setDate(Math.min(n, $P.getDaysInMonth(this.getFullYear(), this.getMonth())));
	        return this;
	    };
	
	    /**
	     * Adds the specified number of years to this instance. 
	     * @param {Number}   The number of years to add. The number can be positive or negative [Required]
	     * @return {Date}    this
	     */
	    $P.addYears = function (value) {
	        return this.addMonths(value * 12);
	    };
	
	    /**
	     * Adds (or subtracts) to the value of the years, months, weeks, days, hours, minutes, seconds, milliseconds of the date instance using given configuration object. Positive and Negative values allowed.
	     * Example
	    <pre><code>
	    Date.today().add( { days: 1, months: 1 } )
	     
	    new Date().add( { years: -1 } )
	    </code></pre> 
	     * @param {Object}   Configuration object containing attributes (months, days, etc.)
	     * @return {Date}    this
	     */
	    $P.add = function (config) {
	        if (typeof config == "number") {
	            this._orient = config;
	            return this;    
	        }
	        
	        var x = config;
	        
	        if (x.milliseconds) { 
	            this.addMilliseconds(x.milliseconds); 
	        }
	        if (x.seconds) { 
	            this.addSeconds(x.seconds); 
	        }
	        if (x.minutes) { 
	            this.addMinutes(x.minutes); 
	        }
	        if (x.hours) { 
	            this.addHours(x.hours); 
	        }
	        if (x.weeks) { 
	            this.addWeeks(x.weeks); 
	        }    
	        if (x.months) { 
	            this.addMonths(x.months); 
	        }
	        if (x.years) { 
	            this.addYears(x.years); 
	        }
	        if (x.days) {
	            this.addDays(x.days); 
	        }
	        return this;
	    };
	    
	    var $y, $m, $d;
	    
	    /**
	     * Get the week number. Week one (1) is the week which contains the first Thursday of the year. Monday is considered the first day of the week.
	     * This algorithm is a JavaScript port of the work presented by Claus Tondering at http://www.tondering.dk/claus/cal/node8.html#SECTION00880000000000000000
	     * .getWeek() Algorithm Copyright (c) 2008 Claus Tondering.
	     * The .getWeek() function does NOT convert the date to UTC. The local datetime is used. Please use .getISOWeek() to get the week of the UTC converted date.
	     * @return {Number}  1 to 53
	     */
	    $P.getWeek = function () {
	        var a, b, c, d, e, f, g, n, s, w;
	        
	        $y = (!$y) ? this.getFullYear() : $y;
	        $m = (!$m) ? this.getMonth() + 1 : $m;
	        $d = (!$d) ? this.getDate() : $d;
	
	        if ($m <= 2) {
	            a = $y - 1;
	            b = (a / 4 | 0) - (a / 100 | 0) + (a / 400 | 0);
	            c = ((a - 1) / 4 | 0) - ((a - 1) / 100 | 0) + ((a - 1) / 400 | 0);
	            s = b - c;
	            e = 0;
	            f = $d - 1 + (31 * ($m - 1));
	        } else {
	            a = $y;
	            b = (a / 4 | 0) - (a / 100 | 0) + (a / 400 | 0);
	            c = ((a - 1) / 4 | 0) - ((a - 1) / 100 | 0) + ((a - 1) / 400 | 0);
	            s = b - c;
	            e = s + 1;
	            f = $d + ((153 * ($m - 3) + 2) / 5) + 58 + s;
	        }
	        
	        g = (a + b) % 7;
	        d = (f + g - e) % 7;
	        n = (f + 3 - d) | 0;
	
	        if (n < 0) {
	            w = 53 - ((g - s) / 5 | 0);
	        } else if (n > 364 + s) {
	            w = 1;
	        } else {
	            w = (n / 7 | 0) + 1;
	        }
	        
	        $y = $m = $d = null;
	        
	        return w;
	    };
	    
	    /**
	     * Get the ISO 8601 week number. Week one ("01") is the week which contains the first Thursday of the year. Monday is considered the first day of the week.
	     * The .getISOWeek() function does convert the date to it's UTC value. Please use .getWeek() to get the week of the local date.
	     * @return {String}  "01" to "53"
	     */
	    $P.getISOWeek = function () {
	        $y = this.getUTCFullYear();
	        $m = this.getUTCMonth() + 1;
	        $d = this.getUTCDate();
	        return p(this.getWeek());
	    };
	
	    /**
	     * Moves the date to Monday of the week set. Week one (1) is the week which contains the first Thursday of the year.
	     * @param {Number}   A Number (1 to 53) that represents the week of the year.
	     * @return {Date}    this
	     */    
	    $P.setWeek = function (n) {
	        return this.moveToDayOfWeek(1).addWeeks(n - this.getWeek());
	    };
	
	    // private
	    var validate = function (n, min, max, name) {
	        if (typeof n == "undefined") {
	            return false;
	        } else if (typeof n != "number") {
	            throw new TypeError(n + " is not a Number."); 
	        } else if (n < min || n > max) {
	            throw new RangeError(n + " is not a valid value for " + name + "."); 
	        }
	        return true;
	    };
	
	    /**
	     * Validates the number is within an acceptable range for milliseconds [0-999].
	     * @param {Number}   The number to check if within range.
	     * @return {Boolean} true if within range, otherwise false.
	     */
	    $P.validateMillisecond = function (value) {
	        return validate(value, 0, 999, "millisecond");
	    };
	
	    /**
	     * Validates the number is within an acceptable range for seconds [0-59].
	     * @param {Number}   The number to check if within range.
	     * @return {Boolean} true if within range, otherwise false.
	     */
	    $P.validateSecond = function (value) {
	        return validate(value, 0, 59, "second");
	    };
	
	    /**
	     * Validates the number is within an acceptable range for minutes [0-59].
	     * @param {Number}   The number to check if within range.
	     * @return {Boolean} true if within range, otherwise false.
	     */
	    $P.validateMinute = function (value) {
	        return validate(value, 0, 59, "minute");
	    };
	
	    /**
	     * Validates the number is within an acceptable range for hours [0-23].
	     * @param {Number}   The number to check if within range.
	     * @return {Boolean} true if within range, otherwise false.
	     */
	    $P.validateHour = function (value) {
	        return validate(value, 0, 23, "hour");
	    };
	
	    /**
	     * Validates the number is within an acceptable range for the days in a month [0-MaxDaysInMonth].
	     * @param {Number}   The number to check if within range.
	     * @return {Boolean} true if within range, otherwise false.
	     */
	    $P.validateDay = function (value, year, month) {
	        return validate(value, 1, $P.getDaysInMonth(year, month), "day");
	    };
	
	    /**
	     * Validates the number is within an acceptable range for months [0-11].
	     * @param {Number}   The number to check if within range.
	     * @return {Boolean} true if within range, otherwise false.
	     */
	    $P.validateMonth = function (value) {
	        return validate(value, 0, 11, "month");
	    };
	
	    /**
	     * Validates the number is within an acceptable range for years.
	     * @param {Number}   The number to check if within range.
	     * @return {Boolean} true if within range, otherwise false.
	     */
	    $P.validateYear = function (value) {
	        return validate(value, 0, 9999, "year");
	    };
	
	    /**
	     * Set the value of year, month, day, hour, minute, second, millisecond of date instance using given configuration object.
	     * Example
	    <pre><code>
	    Date.today().set( { day: 20, month: 1 } )
	
	    new Date().set( { millisecond: 0 } )
	    </code></pre>
	     * 
	     * @param {Object}   Configuration object containing attributes (month, day, etc.)
	     * @return {Date}    this
	     */
	    $P.set = function (config) {
	        if ($P.validateMillisecond(config.millisecond)) {
	            this.addMilliseconds(config.millisecond - this.getMilliseconds()); 
	        }
	        
	        if ($P.validateSecond(config.second)) {
	            this.addSeconds(config.second - this.getSeconds()); 
	        }
	        
	        if ($P.validateMinute(config.minute)) {
	            this.addMinutes(config.minute - this.getMinutes()); 
	        }
	        
	        if ($P.validateHour(config.hour)) {
	            this.addHours(config.hour - this.getHours()); 
	        }
	        
	        if ($P.validateMonth(config.month)) {
	            this.addMonths(config.month - this.getMonth()); 
	        }
	
	        if ($P.validateYear(config.year)) {
	            this.addYears(config.year - this.getFullYear()); 
	        }
	        
		    /* day has to go last because you can't validate the day without first knowing the month */
	        if ($P.validateDay(config.day, this.getFullYear(), this.getMonth())) {
	            this.addDays(config.day - this.getDate()); 
	        }
	        
	        if (config.timezone) { 
	            this.setTimezone(config.timezone); 
	        }
	        
	        if (config.timezoneOffset) { 
	            this.setTimezoneOffset(config.timezoneOffset); 
	        }
	
	        if (config.week && validate(config.week, 0, 53, "week")) {
	            this.setWeek(config.week);
	        }
	        
	        return this;   
	    };
	
	    /**
	     * Moves the date to the first day of the month.
	     * @return {Date}    this
	     */
	    $P.moveToFirstDayOfMonth = function () {
	        return this.set({ day: 1 });
	    };
	
	    /**
	     * Moves the date to the last day of the month.
	     * @return {Date}    this
	     */
	    $P.moveToLastDayOfMonth = function () { 
	        return this.set({ day: $P.getDaysInMonth(this.getFullYear(), this.getMonth())});
	    };
	
	    /**
	     * Moves the date to the next n'th occurrence of the dayOfWeek starting from the beginning of the month. The number (-1) is a magic number and will return the last occurrence of the dayOfWeek in the month.
	     * @param {Number}   The dayOfWeek to move to
	     * @param {Number}   The n'th occurrence to move to. Use (-1) to return the last occurrence in the month
	     * @return {Date}    this
	     */
	    $P.moveToNthOccurrence = function (dayOfWeek, occurrence) {
	        var shift = 0;
	        if (occurrence > 0) {
	            shift = occurrence - 1;
	        }
	        else if (occurrence === -1) {
	            this.moveToLastDayOfMonth();
	            if (this.getDay() !== dayOfWeek) {
	                this.moveToDayOfWeek(dayOfWeek, -1);
	            }
	            return this;
	        }
	        return this.moveToFirstDayOfMonth().addDays(-1).moveToDayOfWeek(dayOfWeek, +1).addWeeks(shift);
	    };
	
	    /**
	     * Move to the next or last dayOfWeek based on the orient value.
	     * @param {Number}   The dayOfWeek to move to
	     * @param {Number}   Forward (+1) or Back (-1). Defaults to +1. [Optional]
	     * @return {Date}    this
	     */
	    $P.moveToDayOfWeek = function (dayOfWeek, orient) {
	        var diff = (dayOfWeek - this.getDay() + 7 * (orient || +1)) % 7;
	        return this.addDays((diff === 0) ? diff += 7 * (orient || +1) : diff);
	    };
	
	    /**
	     * Move to the next or last month based on the orient value.
	     * @param {Number}   The month to move to. 0 = January, 11 = December
	     * @param {Number}   Forward (+1) or Back (-1). Defaults to +1. [Optional]
	     * @return {Date}    this
	     */
	    $P.moveToMonth = function (month, orient) {
	        var diff = (month - this.getMonth() + 12 * (orient || +1)) % 12;
	        return this.addMonths((diff === 0) ? diff += 12 * (orient || +1) : diff);
	    };
	
	    /**
	     * Get the Ordinal day (numeric day number) of the year, adjusted for leap year.
	     * @return {Number} 1 through 365 (366 in leap years)
	     */
	    $P.getOrdinalNumber = function () {
	        return Math.ceil((this.clone().clearTime() - new Date(this.getFullYear(), 0, 1)) / 86400000) + 1;
	    };
	
	    /**
	     * Get the time zone abbreviation of the current date.
	     * @return {String} The abbreviated time zone name (e.g. "EST")
	     */
	    $P.getTimezone = function () {
	        return $P.getTimezoneAbbreviation(this.getUTCOffset());
	    };
	
	    $P.setTimezoneOffset = function (offset) {
	        var here = this.getTimezoneOffset(), there = Number(offset) * -6 / 10;
	        return this.addMinutes(there - here); 
	    };
	
	    $P.setTimezone = function (offset) { 	    	
	        return this.setTimezoneOffset($P.getTimezoneOffset(offset)); 
	    };
	
	    /**
	     * Indicates whether Daylight Saving Time is observed in the current time zone.
	     * @return {Boolean} true|false
	     */
	    $P.hasDaylightSavingTime = function () { 
	        return (Date.today().set({month: 0, day: 1}).getTimezoneOffset() !== Date.today().set({month: 6, day: 1}).getTimezoneOffset());
	    };
	    
	    /**
	     * Indicates whether this Date instance is within the Daylight Saving Time range for the current time zone.
	     * @return {Boolean} true|false
	     */
	    $P.isDaylightSavingTime = function () {
	        return Date.today().set({month: 0, day: 1}).getTimezoneOffset() != this.getTimezoneOffset();
	    };
	
	    /**
	     * Get the offset from UTC of the current date.
	     * @return {String} The 4-character offset string prefixed with + or - (e.g. "-0500")
	     */
	    $P.getUTCOffset = function () {
	        var n = this.getTimezoneOffset() * -10 / 6, r;
	        if (n < 0) { 
	            r = (n - 10000).toString(); 
	            return r.charAt(0) + r.substr(2); 
	        } else { 
	            r = (n + 10000).toString();  
	            return "+" + r.substr(1); 
	        }
	    };
	
	    /**
	     * Returns the number of milliseconds between this date and date.
	     * @param {Date} Defaults to now
	     * @return {Number} The diff in milliseconds
	     */
	    $P.getElapsed = function (date) {
	        return (date || new Date()) - this;
	    };
	
	    if (!$P.toISOString) {
	        /**
	         * Converts the current date instance into a string with an ISO 8601 format. The date is converted to it's UTC value.
	         * @return {String}  ISO 8601 string of date
	         */
	        $P.toISOString = function () {
	            // From http://www.json.org/json.js. Public Domain. 
	            function f(n) {
	                return n < 10 ? '0' + n : n;
	            }
	
	            return '"' + this.getUTCFullYear()   + '-' +
	                f(this.getUTCMonth() + 1) + '-' +
	                f(this.getUTCDate())      + 'T' +
	                f(this.getUTCHours())     + ':' +
	                f(this.getUTCMinutes())   + ':' +
	                f(this.getUTCSeconds())   + 'Z"';
	        };
	    }
	    
	    // private
	    $P._toString = $P.toString;
	
	    /**
	     * Converts the value of the current Date object to its equivalent string representation.
	     * Format Specifiers
	    <pre>
	    CUSTOM DATE AND TIME FORMAT STRINGS
	    Format  Description                                                                  Example
	    ------  ---------------------------------------------------------------------------  -----------------------
	     s      The seconds of the minute between 0-59.                                      "0" to "59"
	     ss     The seconds of the minute with leading zero if required.                     "00" to "59"
	     
	     m      The minute of the hour between 0-59.                                         "0"  or "59"
	     mm     The minute of the hour with leading zero if required.                        "00" or "59"
	     
	     h      The hour of the day between 1-12.                                            "1"  to "12"
	     hh     The hour of the day with leading zero if required.                           "01" to "12"
	     
	     H      The hour of the day between 0-23.                                            "0"  to "23"
	     HH     The hour of the day with leading zero if required.                           "00" to "23"
	     
	     d      The day of the month between 1 and 31.                                       "1"  to "31"
	     dd     The day of the month with leading zero if required.                          "01" to "31"
	     ddd    Abbreviated day name. $C.abbreviatedDayNames.                                "Mon" to "Sun" 
	     dddd   The full day name. $C.dayNames.                                              "Monday" to "Sunday"
	     
	     M      The month of the year between 1-12.                                          "1" to "12"
	     MM     The month of the year with leading zero if required.                         "01" to "12"
	     MMM    Abbreviated month name. $C.abbreviatedMonthNames.                            "Jan" to "Dec"
	     MMMM   The full month name. $C.monthNames.                                          "January" to "December"
	
	     yy     The year as a two-digit number.                                              "99" or "08"
	     yyyy   The full four digit year.                                                    "1999" or "2008"
	     
	     t      Displays the first character of the A.M./P.M. designator.                    "A" or "P"
	            $C.amDesignator or $C.pmDesignator
	     tt     Displays the A.M./P.M. designator.                                           "AM" or "PM"
	            $C.amDesignator or $C.pmDesignator
	     
	     S      The ordinal suffix ("st, "nd", "rd" or "th") of the current day.            "st, "nd", "rd" or "th"
	
	|| *Format* || *Description* || *Example* ||
	|| d      || The CultureInfo shortDate Format Pattern                                     || "M/d/yyyy" ||
	|| D      || The CultureInfo longDate Format Pattern                                      || "dddd, MMMM dd, yyyy" ||
	|| F      || The CultureInfo fullDateTime Format Pattern                                  || "dddd, MMMM dd, yyyy h:mm:ss tt" ||
	|| m      || The CultureInfo monthDay Format Pattern                                      || "MMMM dd" ||
	|| r      || The CultureInfo rfc1123 Format Pattern                                       || "ddd, dd MMM yyyy HH:mm:ss GMT" ||
	|| s      || The CultureInfo sortableDateTime Format Pattern                              || "yyyy-MM-ddTHH:mm:ss" ||
	|| t      || The CultureInfo shortTime Format Pattern                                     || "h:mm tt" ||
	|| T      || The CultureInfo longTime Format Pattern                                      || "h:mm:ss tt" ||
	|| u      || The CultureInfo universalSortableDateTime Format Pattern                     || "yyyy-MM-dd HH:mm:ssZ" ||
	|| y      || The CultureInfo yearMonth Format Pattern                                     || "MMMM, yyyy" ||
	     
	
	    STANDARD DATE AND TIME FORMAT STRINGS
	    Format  Description                                                                  Example ("en-US")
	    ------  ---------------------------------------------------------------------------  -----------------------
	     d      The CultureInfo shortDate Format Pattern                                     "M/d/yyyy"
	     D      The CultureInfo longDate Format Pattern                                      "dddd, MMMM dd, yyyy"
	     F      The CultureInfo fullDateTime Format Pattern                                  "dddd, MMMM dd, yyyy h:mm:ss tt"
	     m      The CultureInfo monthDay Format Pattern                                      "MMMM dd"
	     r      The CultureInfo rfc1123 Format Pattern                                       "ddd, dd MMM yyyy HH:mm:ss GMT"
	     s      The CultureInfo sortableDateTime Format Pattern                              "yyyy-MM-ddTHH:mm:ss"
	     t      The CultureInfo shortTime Format Pattern                                     "h:mm tt"
	     T      The CultureInfo longTime Format Pattern                                      "h:mm:ss tt"
	     u      The CultureInfo universalSortableDateTime Format Pattern                     "yyyy-MM-dd HH:mm:ssZ"
	     y      The CultureInfo yearMonth Format Pattern                                     "MMMM, yyyy"
	    </pre>
	     * @param {String}   A format string consisting of one or more format spcifiers [Optional].
	     * @return {String}  A string representation of the current Date object.
	     */
	    $P.toString = function (format) {
	        var x = this;
	        
	        // Standard Date and Time Format Strings. Formats pulled from CultureInfo file and
	        // may vary by culture. 
	        if (format && format.length == 1) {
	            var c = $C.formatPatterns;
	            x.t = x.toString;
	            switch (format) {
	            case "d": 
	                return x.t(c.shortDate);
	            case "D":
	                return x.t(c.longDate);
	            case "F":
	                return x.t(c.fullDateTime);
	            case "m":
	                return x.t(c.monthDay);
	            case "r":
	                return x.t(c.rfc1123);
	            case "s":
	                return x.t(c.sortableDateTime);
	            case "t":
	                return x.t(c.shortTime);
	            case "T":
	                return x.t(c.longTime);
	            case "u":
	                return x.t(c.universalSortableDateTime);
	            case "y":
	                return x.t(c.yearMonth);
	            }    
	        }
	        
	        var ord = function (n) {
	                switch (n * 1) {
	                case 1: 
	                case 21: 
	                case 31: 
	                    return "st";
	                case 2: 
	                case 22: 
	                    return "nd";
	                case 3: 
	                case 23: 
	                    return "rd";
	                default: 
	                    return "th";
	                }
	            };
	        
	        return format ? format.replace(/(\\)?(dd?d?d?|MM?M?M?|yy?y?y?|hh?|HH?|mm?|ss?|tt?|S)/g, 
	        function (m) {
	            if (m.charAt(0) === "\\") {
	                return m.replace("\\", "");
	            }
	            x.h = x.getHours;
	            switch (m) {
	            case "hh":
	                return p(x.h() < 13 ? (x.h() === 0 ? 12 : x.h()) : (x.h() - 12));
	            case "h":
	                return x.h() < 13 ? (x.h() === 0 ? 12 : x.h()) : (x.h() - 12);
	            case "HH":
	                return p(x.h());
	            case "H":
	                return x.h();
	            case "mm":
	                return p(x.getMinutes());
	            case "m":
	                return x.getMinutes();
	            case "ss":
	                return p(x.getSeconds());
	            case "s":
	                return x.getSeconds();
	            case "yyyy":
	                return p(x.getFullYear(), 4);
	            case "yy":
	                return p(x.getFullYear());
	            case "dddd":
	                return $C.dayNames[x.getDay()];
	            case "ddd":
	                return $C.abbreviatedDayNames[x.getDay()];
	            case "dd":
	                return p(x.getDate());
	            case "d":
	                return x.getDate();
	            case "MMMM":
	                return $C.monthNames[x.getMonth()];
	            case "MMM":
	                return $C.abbreviatedMonthNames[x.getMonth()];
	            case "MM":
	                return p((x.getMonth() + 1));
	            case "M":
	                return x.getMonth() + 1;
	            case "t":
	                return x.h() < 12 ? $C.amDesignator.substring(0, 1) : $C.pmDesignator.substring(0, 1);
	            case "tt":
	                return x.h() < 12 ? $C.amDesignator : $C.pmDesignator;
	            case "S":
	                return ord(x.getDate());
	            default: 
	                return m;
	            }
	        }
	        ) : this._toString();
	    };
	}()); 

// #endregion
	
// #region *******************************      Parser      *********************************

	(function () {
	    Date.prototype.Parsing = {
	        Exception: function (s) {
	            this.message = "Parse error at '" + s.substring(0, 10) + " ...'"; 
	        }
	    };
	    
	    var $P = Date.prototype.Parsing; 
	    var _ = $P.Operators = {
	        //
	        // Tokenizers
	        //
	        rtoken: function (r) { // regex token
	            return function (s) {
	                var mx = s.match(r);
	                if (mx) { 
	                    return ([ mx[0], s.substring(mx[0].length) ]); 
	                } else { 
	                    throw new $P.Exception(s); 
	                }
	            };
	        },
	        token: function (s) { // whitespace-eating token
	            return function (s) {
	                return _.rtoken(new RegExp("^\s*" + s + "\s*"))(s);
	                // Removed .strip()
	                // return _.rtoken(new RegExp("^\s*" + s + "\s*"))(s).strip();
	            };
	        },
	        stoken: function (s) { // string token
	            return _.rtoken(new RegExp("^" + s)); 
	        },
	
	        //
	        // Atomic Operators
	        // 
	
	        until: function (p) {
	            return function (s) {
	                var qx = [], rx = null;
	                while (s.length) { 
	                    try { 
	                        rx = p.call(this, s); 
	                    } catch (e) { 
	                        qx.push(rx[0]); 
	                        s = rx[1]; 
	                        continue; 
	                    }
	                    break;
	                }
	                return [ qx, s ];
	            };
	        },
	        many: function (p) {
	            return function (s) {
	                var rx = [], r = null; 
	                while (s.length) { 
	                    try { 
	                        r = p.call(this, s); 
	                    } catch (e) { 
	                        return [ rx, s ]; 
	                    }
	                    rx.push(r[0]); 
	                    s = r[1];
	                }
	                return [ rx, s ];
	            };
	        },
	
	        // generator operators -- see below
	        optional: function (p) {
	            return function (s) {
	                var r = null; 
	                try { 
	                    r = p.call(this, s); 
	                } catch (e) { 
	                    return [ null, s ]; 
	                }
	                return [ r[0], r[1] ];
	            };
	        },
	        not: function (p) {
	            return function (s) {
	                try { 
	                    p.call(this, s); 
	                } catch (e) { 
	                    return [null, s]; 
	                }
	                throw new $P.Exception(s);
	            };
	        },
	        ignore: function (p) {
	            return p ? 
	            function (s) { 
	                var r = null; 
	                r = p.call(this, s); 
	                return [null, r[1]]; 
	            } : null;
	        },
	        product: function () {
	            var px = arguments[0], 
	            qx = Array.prototype.slice.call(arguments, 1), rx = [];
	            for (var i = 0 ; i < px.length ; i++) {
	                rx.push(_.each(px[i], qx));
	            }
	            return rx;
	        },
	        cache: function (rule) { 
	            var cache = {}, r = null; 
	            return function (s) {
	                try { 
	                    r = cache[s] = (cache[s] || rule.call(this, s)); 
	                } catch (e) { 
	                    r = cache[s] = e; 
	                }
	                if (r instanceof $P.Exception) { 
	                    throw r; 
	                } else { 
	                    return r; 
	                }
	            };
	        },
	    	  
	        // vector operators -- see below
	        any: function () {
	            var px = arguments;
	            return function (s) { 
	                var r = null;
	                for (var i = 0; i < px.length; i++) { 
	                    if (px[i] == null) { 
	                        continue; 
	                    }
	                    try { 
	                        r = (px[i].call(this, s)); 
	                    } catch (e) { 
	                        r = null; 
	                    }
	                    if (r) { 
	                        return r; 
	                    }
	                } 
	                throw new $P.Exception(s);
	            };
	        },
	        each: function () { 
	            var px = arguments;
	            return function (s) { 
	                var rx = [], r = null;
	                for (var i = 0; i < px.length ; i++) { 
	                    if (px[i] == null) { 
	                        continue; 
	                    }
	                    try { 
	                        r = (px[i].call(this, s)); 
	                    } catch (e) { 
	                        throw new $P.Exception(s); 
	                    }
	                    rx.push(r[0]); 
	                    s = r[1];
	                }
	                return [ rx, s]; 
	            };
	        },
	        all: function () { 
	            var px = arguments, _ = _; 
	            return _.each(_.optional(px)); 
	        },
	
	        // delimited operators
	        sequence: function (px, d, c) {
	            d = d || _.rtoken(/^\s*/);  
	            c = c || null;
	            
	            if (px.length == 1) { 
	                return px[0]; 
	            }
	            return function (s) {
	                var r = null, q = null;
	                var rx = []; 
	                for (var i = 0; i < px.length ; i++) {
	                    try { 
	                        r = px[i].call(this, s); 
	                    } catch (e) { 
	                        break; 
	                    }
	                    rx.push(r[0]);
	                    try { 
	                        q = d.call(this, r[1]); 
	                    } catch (ex) { 
	                        q = null; 
	                        break; 
	                    }
	                    s = q[1];
	                }
	                if (!r) { 
	                    throw new $P.Exception(s); 
	                }
	                if (q) { 
	                    throw new $P.Exception(q[1]); 
	                }
	                if (c) {
	                    try { 
	                        r = c.call(this, r[1]);
	                    } catch (ey) { 
	                        throw new $P.Exception(r[1]); 
	                    }
	                }
	                return [ rx, (r?r[1]:s) ];
	            };
	        },
	    		
		    //
		    // Composite Operators
		    //
	    		
	        between: function (d1, p, d2) { 
	            d2 = d2 || d1; 
	            var _fn = _.each(_.ignore(d1), p, _.ignore(d2));
	            return function (s) { 
	                var rx = _fn.call(this, s); 
	                return [[rx[0][0], r[0][2]], rx[1]]; 
	            };
	        },
	        list: function (p, d, c) {
	            d = d || _.rtoken(/^\s*/);  
	            c = c || null;
	            return (p instanceof Array ?
	                _.each(_.product(p.slice(0, -1), _.ignore(d)), p.slice(-1), _.ignore(c)) :
	                _.each(_.many(_.each(p, _.ignore(d))), px, _.ignore(c)));
	        },
	        set: function (px, d, c) {
	            d = d || _.rtoken(/^\s*/); 
	            c = c || null;
	            return function (s) {
	                // r is the current match, best the current 'best' match
	                // which means it parsed the most amount of input
	                var r = null, p = null, q = null, rx = null, best = [[], s], last = false;
	
	                // go through the rules in the given set
	                for (var i = 0; i < px.length ; i++) {
	
	                    // last is a flag indicating whether this must be the last element
	                    // if there is only 1 element, then it MUST be the last one
	                    q = null; 
	                    p = null; 
	                    r = null; 
	                    last = (px.length == 1); 
	
	                    // first, we try simply to match the current pattern
	                    // if not, try the next pattern
	                    try { 
	                        r = px[i].call(this, s);
	                    } catch (e) { 
	                        continue; 
	                    }
	
	                    // since we are matching against a set of elements, the first
	                    // thing to do is to add r[0] to matched elements
	                    rx = [[r[0]], r[1]];
	
	                    // if we matched and there is still input to parse and 
	                    // we don't already know this is the last element,
	                    // we're going to next check for the delimiter ...
	                    // if there's none, or if there's no input left to parse
	                    // than this must be the last element after all ...
	                    if (r[1].length > 0 && ! last) {
	                        try { 
	                            q = d.call(this, r[1]); 
	                        } catch (ex) { 
	                            last = true; 
	                        }
	                    } else { 
	                        last = true; 
	                    }
	
					    // if we parsed the delimiter and now there's no more input,
					    // that means we shouldn't have parsed the delimiter at all
					    // so don't update r and mark this as the last element ...
	                    if (!last && q[1].length === 0) { 
	                        last = true; 
	                    }
	
	
					    // so, if this isn't the last element, we're going to see if
					    // we can get any more matches from the remaining (unmatched)
					    // elements ...
	                    if (!last) {
	
	                        // build a list of the remaining rules we can match against,
	                        // i.e., all but the one we just matched against
	                        var qx = []; 
	                        for (var j = 0; j < px.length ; j++) { 
	                            if (i != j) { 
	                                qx.push(px[j]); 
	                            }
	                        }
	
	                        // now invoke recursively set with the remaining input
	                        // note that we don't include the closing delimiter ...
	                        // we'll check for that ourselves at the end
	                        p = _.set(qx, d).call(this, q[1]);
	
	                        // if we got a non-empty set as a result ...
	                        // (otw rx already contains everything we want to match)
	                        if (p[0].length > 0) {
	                            // update current result, which is stored in rx ...
	                            // basically, pick up the remaining text from p[1]
	                            // and concat the result from p[0] so that we don't
	                            // get endless nesting ...
	                            rx[0] = rx[0].concat(p[0]); 
	                            rx[1] = p[1]; 
	                        }
	                    }
	
					    // at this point, rx either contains the last matched element
					    // or the entire matched set that starts with this element.
	
					    // now we just check to see if this variation is better than
					    // our best so far, in terms of how much of the input is parsed
	                    if (rx[1].length < best[1].length) { 
	                        best = rx; 
	                    }
	
					    // if we've parsed all the input, then we're finished
	                    if (best[1].length === 0) { 
	                        break; 
	                    }
	                }
	
				    // so now we've either gone through all the patterns trying them
				    // as the initial match; or we found one that parsed the entire
				    // input string ...
	
				    // if best has no matches, just return empty set ...
	                if (best[0].length === 0) { 
	                    return best; 
	                }
	
				    // if a closing delimiter is provided, then we have to check it also
	                if (c) {
	                    // we try this even if there is no remaining input because the pattern
	                    // may well be optional or match empty input ...
	                    try { 
	                        q = c.call(this, best[1]); 
	                    } catch (ey) { 
	                        throw new $P.Exception(best[1]); 
	                    }
	
	                    // it parsed ... be sure to update the best match remaining input
	                    best[1] = q[1];
	                }
	
				    // if we're here, either there was no closing delimiter or we parsed it
				    // so now we have the best match; just return it!
	                return best;
	            };
	        },
	        forward: function (gr, fname) {
	            return function (s) { 
	                return gr[fname].call(this, s); 
	            };
	        },
	
	        //
	        // Translation Operators
	        //
	        replace: function (rule, repl) {
	            return function (s) { 
	                var r = rule.call(this, s); 
	                return [repl, r[1]]; 
	            };
	        },
	        process: function (rule, fn) {
	            return function (s) {  
	                var r = rule.call(this, s); 
	                return [fn.call(this, r[0]), r[1]]; 
	            };
	        },
	        min: function (min, rule) {
	            return function (s) {
	                var rx = rule.call(this, s); 
	                if (rx[0].length < min) { 
	                    throw new $P.Exception(s); 
	                }
	                return rx;
	            };
	        }
	    };
		
	
		// Generator Operators And Vector Operators
	
		// Generators are operators that have a signature of F(R) => R,
		// taking a given rule and returning another rule, such as 
		// ignore, which parses a given rule and throws away the result.
	
		// Vector operators are those that have a signature of F(R1,R2,...) => R,
		// take a list of rules and returning a new rule, such as each.
	
		// Generator operators are converted (via the following _generator
		// function) into functions that can also take a list or array of rules
		// and return an array of new rules as though the function had been
		// called on each rule in turn (which is what actually happens).
	
		// This allows generators to be used with vector operators more easily.
		// Example:
		// each(ignore(foo, bar)) instead of each(ignore(foo), ignore(bar))
	
		// This also turns generators into vector operators, which allows
		// constructs like:
		// not(cache(foo, bar))
		
	    var _generator = function (op) {
	        return function () {
	            var args = null, rx = [];
	            if (arguments.length > 1) {
	                args = Array.prototype.slice.call(arguments);
	            } else if (arguments[0] instanceof Array) {
	                args = arguments[0];
	            }
	            if (args) { 
	                for (var i = 0, px = args.shift() ; i < px.length ; i++) {
	                    args.unshift(px[i]); 
	                    rx.push(op.apply(null, args)); 
	                    args.shift();
	                    return rx;
	                } 
	            } else { 
	                return op.apply(null, arguments); 
	            }
	        };
	    };
	    
	    var gx = "optional not ignore cache".split(/\s/);
	    
	    for (var i = 0 ; i < gx.length ; i++) { 
	        _[gx[i]] = _generator(_[gx[i]]); 
	    }
	
	    var _vector = function (op) {
	        return function () {
	            if (arguments[0] instanceof Array) { 
	                return op.apply(null, arguments[0]); 
	            } else { 
	                return op.apply(null, arguments); 
	            }
	        };
	    };
	    
	    var vx = "each any all".split(/\s/);
	    
	    for (var j = 0 ; j < vx.length ; j++) { 
	        _[vx[j]] = _vector(_[vx[j]]); 
	    }
		
	}());
	
	(function () {
	    var $D = Date, $P = $D.prototype, $C = $D.CultureInfo;
	
	    var flattenAndCompact = function (ax) { 
	        var rx = []; 
	        for (var i = 0; i < ax.length; i++) {
	            if (ax[i] instanceof Array) {
	                rx = rx.concat(flattenAndCompact(ax[i]));
	            } else { 
	                if (ax[i]) { 
	                    rx.push(ax[i]); 
	                }
	            }
	        }
	        return rx;
	    };
	    
	    $P.Grammar = {};
		
	    $P.Translator = {
	        hour: function (s) { 
	            return function () { 
	                this.hour = Number(s); 
	            }; 
	        },
	        minute: function (s) { 
	            return function () { 
	                this.minute = Number(s); 
	            }; 
	        },
	        second: function (s) { 
	            return function () { 
	                this.second = Number(s); 
	            }; 
	        },
	        meridian: function (s) { 
	            return function () { 
	                this.meridian = s.slice(0, 1).toLowerCase(); 
	            }; 
	        },
	        timezone: function (s) {
	            return function () {
	                var n = s.replace(/[^\d\+\-]/g, "");
	                if (n.length) { 
	                    this.timezoneOffset = Number(n); 
	                } else { 
	                    this.timezone = s.toLowerCase(); 
	                }
	            };
	        },
	        day: function (x) { 
	            var s = x[0];
	            return function () { 
	                this.day = Number(s.match(/\d+/)[0]); 
	            };
	        }, 
	        month: function (s) {
	            return function () {
	                this.month = (s.length == 3) ? "jan feb mar apr may jun jul aug sep oct nov dec".indexOf(s)/4 : Number(s) - 1;
	            };
	        },
	        year: function (s) {
	            return function () {
	                var n = Number(s);
	                this.year = ((s.length > 2) ? n : 
	                    (n + (((n + 2000) < $C.twoDigitYearMax) ? 2000 : 1900))); 
	            };
	        },
	        rday: function (s) { 
	            return function () {
	                switch (s) {
	                case "yesterday": 
	                    this.days = -1;
	                    break;
	                case "tomorrow":  
	                    this.days = 1;
	                    break;
	                case "today": 
	                    this.days = 0;
	                    break;
	                case "now": 
	                    this.days = 0; 
	                    this.now = true; 
	                    break;
	                }
	            };
	        },
	        finishExact: function (x) {  
	            x = (x instanceof Array) ? x : [ x ]; 
	
	            for (var i = 0 ; i < x.length ; i++) { 
	                if (x[i]) { 
	                    x[i].call(this); 
	                }
	            }
	            
	            var now = new Date();
	            
	            if ((this.hour || this.minute) && (!this.month && !this.year && !this.day)) {
	                this.day = now.getDate();
	            }
	
	            if (!this.year) {
	                this.year = now.getFullYear();
	            }
	            
	            if (!this.month && this.month !== 0) {
	                this.month = now.getMonth();
	            }
	            
	            if (!this.day) {
	                this.day = 1;
	            }
	            
	            if (!this.hour) {
	                this.hour = 0;
	            }
	            
	            if (!this.minute) {
	                this.minute = 0;
	            }
	
	            if (!this.second) {
	                this.second = 0;
	            }
	
	            if (this.meridian && this.hour) {
	                if (this.meridian == "p" && this.hour < 12) {
	                    this.hour = this.hour + 12;
	                } else if (this.meridian == "a" && this.hour == 12) {
	                    this.hour = 0;
	                }
	            }
	            
	            if (this.day > $P.getDaysInMonth(this.year, this.month)) {
	                throw new RangeError(this.day + " is not a valid value for days.");
	            }
	
	            var r = new Date(this.year, this.month, this.day, this.hour, this.minute, this.second);
				
	            if (this.timezone) { 
	                r.set({ timezone: this.timezone }); 
	            } else if (this.timezoneOffset) { 
	                r.set({ timezoneOffset: this.timezoneOffset }); 
	            }
	            
	            return r;
	        },			
	        finish: function (x) {
	            x = (x instanceof Array) ? flattenAndCompact(x) : [ x ];
	
	            if (x.length === 0) { 
	                return null; 
	            }
	
	            for (var i = 0 ; i < x.length ; i++) { 
	                if (typeof x[i] == "function") {
	                    x[i].call(this); 
	                }
	            }
	            
	            var today = $P.today();
	            
	            if (this.now && !this.unit && !this.operator) { 
	                return new Date(); 
	            } else if (this.now) {
	                today = new Date();
	            }
	            
	            var expression = !!(this.days && this.days !== null || this.orient || this.operator);
	            
	            var gap, mod, orient;
	            orient = ((this.orient == "past" || this.operator == "subtract") ? -1 : 1);
	            
	            if(!this.now && "hour minute second".indexOf(this.unit) != -1) {
	                today.setTimeToNow();
	            }
	
	            if (this.month || this.month === 0) {
	                if ("year day hour minute second".indexOf(this.unit) != -1) {
	                    this.value = this.month + 1;
	                    this.month = null;
	                    expression = true;
	                }
	            }
	            
	            if (!expression && this.weekday && !this.day && !this.days) {
	                var temp = Date[this.weekday]();
	                this.day = temp.getDate();
	                if (!this.month) {
	                    this.month = temp.getMonth();
	                }
	                this.year = temp.getFullYear();
	            }
	            
	            if (expression && this.weekday && this.unit != "month") {
	                this.unit = "day";
	                gap = ($P.getDayNumberFromName(this.weekday) - today.getDay());
	                mod = 7;
	                this.days = gap ? ((gap + (orient * mod)) % mod) : (orient * mod);
	            }
	            
	            if (this.month && this.unit == "day" && this.operator) {
	                this.value = (this.month + 1);
	                this.month = null;
	            }
	       
	            if (this.value != null && this.month != null && this.year != null) {
	                this.day = this.value * 1;
	            }
	     
	            if (this.month && !this.day && this.value) {
	                today.set({ day: this.value * 1 });
	                if (!expression) {
	                    this.day = this.value * 1;
	                }
	            }
	
	            if (!this.month && this.value && this.unit == "month" && !this.now) {
	                this.month = this.value;
	                expression = true;
	            }
	
	            if (expression && (this.month || this.month === 0) && this.unit != "year") {
	                this.unit = "month";
	                gap = (this.month - today.getMonth());
	                mod = 12;
	                this.months = gap ? ((gap + (orient * mod)) % mod) : (orient * mod);
	                this.month = null;
	            }
	
	            if (!this.unit) { 
	                this.unit = "day"; 
	            }
	            
	            if (!this.value && this.operator && this.operator !== null && this[this.unit + "s"] && this[this.unit + "s"] !== null) {
	                this[this.unit + "s"] = this[this.unit + "s"] + ((this.operator == "add") ? 1 : -1) + (this.value||0) * orient;
	            } else if (this[this.unit + "s"] == null || this.operator != null) {
	                if (!this.value) {
	                    this.value = 1;
	                }
	                this[this.unit + "s"] = this.value * orient;
	            }
	
	            if (this.meridian && this.hour) {
	                if (this.meridian == "p" && this.hour < 12) {
	                    this.hour = this.hour + 12;
	                } else if (this.meridian == "a" && this.hour == 12) {
	                    this.hour = 0;
	                }
	            }
	            
	            if (this.weekday && !this.day && !this.days) {
	                var temp = Date[this.weekday]();
	                this.day = temp.getDate();
	                if (temp.getMonth() !== today.getMonth()) {
	                    this.month = temp.getMonth();
	                }
	            }
	            
	            if ((this.month || this.month === 0) && !this.day) { 
	                this.day = 1; 
	            }
	            
	            if (!this.orient && !this.operator && this.unit == "week" && this.value && !this.day && !this.month) {
	                return Date.today().setWeek(this.value);
	            }
	
	            if (expression && this.timezone && this.day && this.days) {
	                this.day = this.days;
	            }
	            
	            return (expression) ? today.add(this) : today.set(this);
	        }
	    };
	
	    var _ = $P.Parsing.Operators, g = $P.Grammar, t = $P.Translator, _fn;
	
	    g.datePartDelimiter = _.rtoken(/^([\s\-\.\,\/\x27]+)/); 
	    g.timePartDelimiter = _.stoken(":");
	    g.whiteSpace = _.rtoken(/^\s*/);
	    g.generalDelimiter = _.rtoken(/^(([\s\,]|at|@|on)+)/);
	  
	    var _C = {};
	    g.ctoken = function (keys) {
	        var fn = _C[keys];
	        if (! fn) {
	            var c = $C.regexPatterns;
	            var kx = keys.split(/\s+/), px = []; 
	            for (var i = 0; i < kx.length ; i++) {
	                px.push(_.replace(_.rtoken(c[kx[i]]), kx[i]));
	            }
	            fn = _C[keys] = _.any.apply(null, px);
	        }
	        return fn;
	    };
	    g.ctoken2 = function (key) { 
	        return _.rtoken($C.regexPatterns[key]);
	    };
	
	    // hour, minute, second, meridian, timezone
	    g.h = _.cache(_.process(_.rtoken(/^(0[0-9]|1[0-2]|[1-9])/), t.hour));
	    g.hh = _.cache(_.process(_.rtoken(/^(0[0-9]|1[0-2])/), t.hour));
	    g.H = _.cache(_.process(_.rtoken(/^([0-1][0-9]|2[0-3]|[0-9])/), t.hour));
	    g.HH = _.cache(_.process(_.rtoken(/^([0-1][0-9]|2[0-3])/), t.hour));
	    g.m = _.cache(_.process(_.rtoken(/^([0-5][0-9]|[0-9])/), t.minute));
	    g.mm = _.cache(_.process(_.rtoken(/^[0-5][0-9]/), t.minute));
	    g.s = _.cache(_.process(_.rtoken(/^([0-5][0-9]|[0-9])/), t.second));
	    g.ss = _.cache(_.process(_.rtoken(/^[0-5][0-9]/), t.second));
	    g.hms = _.cache(_.sequence([g.H, g.m, g.s], g.timePartDelimiter));
	  
	    // _.min(1, _.set([ g.H, g.m, g.s ], g._t));
	    g.t = _.cache(_.process(g.ctoken2("shortMeridian"), t.meridian));
	    g.tt = _.cache(_.process(g.ctoken2("longMeridian"), t.meridian));
	    g.z = _.cache(_.process(_.rtoken(/^((\+|\-)\s*\d\d\d\d)|((\+|\-)\d\d\:?\d\d)/), t.timezone));
	    g.zz = _.cache(_.process(_.rtoken(/^((\+|\-)\s*\d\d\d\d)|((\+|\-)\d\d\:?\d\d)/), t.timezone));
	    
	    g.zzz = _.cache(_.process(g.ctoken2("timezone"), t.timezone));
	    g.timeSuffix = _.each(_.ignore(g.whiteSpace), _.set([ g.tt, g.zzz ]));
	    g.time = _.each(_.optional(_.ignore(_.stoken("T"))), g.hms, g.timeSuffix);
	    	  
	    // days, months, years
	    g.d = _.cache(_.process(_.each(_.rtoken(/^([0-2]\d|3[0-1]|\d)/), 
	        _.optional(g.ctoken2("ordinalSuffix"))), t.day));
	    g.dd = _.cache(_.process(_.each(_.rtoken(/^([0-2]\d|3[0-1])/), 
	        _.optional(g.ctoken2("ordinalSuffix"))), t.day));
	    g.ddd = g.dddd = _.cache(_.process(g.ctoken("sun mon tue wed thu fri sat"), 
	        function (s) { 
	            return function () { 
	                this.weekday = s; 
	            }; 
	        }
	    ));
	    g.M = _.cache(_.process(_.rtoken(/^(1[0-2]|0\d|\d)/), t.month));
	    g.MM = _.cache(_.process(_.rtoken(/^(1[0-2]|0\d)/), t.month));
	    g.MMM = g.MMMM = _.cache(_.process(
	        g.ctoken("jan feb mar apr may jun jul aug sep oct nov dec"), t.month));
	    g.y = _.cache(_.process(_.rtoken(/^(\d\d?)/), t.year));
	    g.yy = _.cache(_.process(_.rtoken(/^(\d\d)/), t.year));
	    g.yyy = _.cache(_.process(_.rtoken(/^(\d\d?\d?\d?)/), t.year));
	    g.yyyy = _.cache(_.process(_.rtoken(/^(\d\d\d\d)/), t.year));
		
		// rolling these up into general purpose rules
	    _fn = function () { 
	        return _.each(_.any.apply(null, arguments), _.not(g.ctoken2("timeContext")));
	    };
	    
	    g.day = _fn(g.d, g.dd); 
	    g.month = _fn(g.M, g.MMM); 
	    g.year = _fn(g.yyyy, g.yy);
	
	    // relative date / time expressions
	    g.orientation = _.process(g.ctoken("past future"), 
	        function (s) { 
	            return function () { 
	                this.orient = s; 
	            }; 
	        }
	    );
	    g.operator = _.process(g.ctoken("add subtract"), 
	        function (s) { 
	            return function () { 
	                this.operator = s; 
	            }; 
	        }
	    );  
	    g.rday = _.process(g.ctoken("yesterday tomorrow today now"), t.rday);
	    g.unit = _.process(g.ctoken("second minute hour day week month year"), 
	        function (s) { 
	            return function () { 
	                this.unit = s; 
	            }; 
	        }
	    );
	    g.value = _.process(_.rtoken(/^\d\d?(st|nd|rd|th)?/), 
	        function (s) { 
	            return function () { 
	                this.value = s.replace(/\D/g, ""); 
	            }; 
	        }
	    );
	    g.expression = _.set([ g.rday, g.operator, g.value, g.unit, g.orientation, g.ddd, g.MMM ]);
	
	    // pre-loaded rules for different date part order preferences
	    _fn = function () { 
	        return  _.set(arguments, g.datePartDelimiter); 
	    };
	    g.mdy = _fn(g.ddd, g.month, g.day, g.year);
	    g.ymd = _fn(g.ddd, g.year, g.month, g.day);
	    g.dmy = _fn(g.ddd, g.day, g.month, g.year);
	    g.date = function (s) { 
	        return ((g[$C.dateElementOrder] || g.mdy).call(this, s));
	    }; 
	
	    // parsing date format specifiers - ex: "h:m:s tt" 
	    // this little guy will generate a custom parser based
	    // on the format string, ex: g.format("h:m:s tt")
	    g.format = _.process(_.many(
	        _.any(
	        // translate format specifiers into grammar rules
	        _.process(
	        _.rtoken(/^(dd?d?d?|MM?M?M?|yy?y?y?|hh?|HH?|mm?|ss?|tt?|zz?z?)/), 
	        function (fmt) { 
	        if (g[fmt]) { 
	            return g[fmt]; 
	        } else { 
	            throw $P.Parsing.Exception(fmt); 
	        }
	    }
	    ),
	    // translate separator tokens into token rules
	    _.process(
	    _.rtoken(/^[^dMyhHmstz]+/), // all legal separators 
	        function (s) { 
	            return _.ignore(_.stoken(s)); 
	        } 
	    )
	    )), 
	        // construct the parser ...
	        function (rules) { 
	            return _.process(_.each.apply(null, rules), t.finishExact); 
	        }
	    );
	    
	    var _F = {
			//"M/d/yyyy": function (s) { 
			//	var m = s.match(/^([0-2]\d|3[0-1]|\d)\/(1[0-2]|0\d|\d)\/(\d\d\d\d)/);
			//	if (m!=null) { 
			//		var r =  [ t.month.call(this,m[1]), t.day.call(this,m[2]), t.year.call(this,m[3]) ];
			//		r = t.finishExact.call(this,r);
			//		return [ r, "" ];
			//	} else {
			//		throw new Date.Parsing.Exception(s);
			//	}
			//}
			//"M/d/yyyy": function (s) { return [ new Date(Date._parse(s)), ""]; }
		}; 
	    var _get = function (f) { 
	        return _F[f] = (_F[f] || g.format(f)[0]);      
	    };
	  
	    g.formats = function (fx) {
	        if (typeof(fx) == "object") {
	            var rx = []; 
	            for (var i = 0 ; i < fx.length ; i++) {
	                rx.push(_get(fx[i])); 
	            }
	            return _.any.apply(null, rx);
	        } else { 
	            return _get(fx); 
	        }
	    };
	
		// check for these formats first
	    g._formats = g.formats([
	        "\"yyyy-MM-ddTHH:mm:ssZ\"",
	        "yyyy-MM-ddTHH:mm:ssZ",
	        "yyyy-MM-ddTHH:mm:ssz",
	        "yyyy-MM-ddTHH:mm:ss",
	        "yyyy-MM-ddTHH:mmZ",
	        "yyyy-MM-ddTHH:mmz",
	        "yyyy-MM-ddTHH:mm",
	        "ddd, MMM dd, yyyy H:mm:ss tt",
	        "ddd MMM d yyyy HH:mm:ss zzz",
	        "MMddyyyy",
	        "ddMMyyyy",
	        "Mddyyyy",
	        "ddMyyyy",
	        "Mdyyyy",
	        "dMyyyy",
	        "yyyy",
	        "Mdyy",
	        "dMyy",
	        "d"
	    ]);
	
		// starting rule for general purpose grammar
	    g._start = _.process(_.set([ g.date, g.time, g.expression ], 
	        g.generalDelimiter, g.whiteSpace), t.finish);
		
		// real starting rule: tries selected formats first, 
		// then general purpose rule
	    g.start = function (s) {
	        try { 
	            var r = g._formats.call({}, s); 
	            if (r[1].length === 0) {
	                return r; 
	            }
	        } catch (e) {}
	        return g._start.call({}, s);
	    };
		
		$P._parse = $P.parse;
	
	    /**
	     * Converts the specified string value into its JavaScript Date equivalent using CultureInfo specific format information.
	     * 
	     * Example
	    <pre><code>
	    ///////////
	    // Dates //
	    ///////////
	
	    // 15-Oct-2004
	    var d1 = Date.parse("10/15/2004");
	
	    // 15-Oct-2004
	    var d1 = Date.parse("15-Oct-2004");
	
	    // 15-Oct-2004
	    var d1 = Date.parse("2004.10.15");
	
	    //Fri Oct 15, 2004
	    var d1 = Date.parse("Fri Oct 15, 2004");
	
	    ///////////
	    // Times //
	    ///////////
	
	    // Today at 10 PM.
	    var d1 = Date.parse("10 PM");
	
	    // Today at 10:30 PM.
	    var d1 = Date.parse("10:30 P.M.");
	
	    // Today at 6 AM.
	    var d1 = Date.parse("06am");
	
	    /////////////////////
	    // Dates and Times //
	    /////////////////////
	
	    // 8-July-2004 @ 10:30 PM
	    var d1 = Date.parse("July 8th, 2004, 10:30 PM");
	
	    // 1-July-2004 @ 10:30 PM
	    var d1 = Date.parse("2004-07-01T22:30:00");
	
	    ////////////////////
	    // Relative Dates //
	    ////////////////////
	
	    // Returns today's date. The string "today" is culture specific.
	    var d1 = Date.parse("today");
	
	    // Returns yesterday's date. The string "yesterday" is culture specific.
	    var d1 = Date.parse("yesterday");
	
	    // Returns the date of the next thursday.
	    var d1 = Date.parse("Next thursday");
	
	    // Returns the date of the most previous monday.
	    var d1 = Date.parse("last monday");
	
	    // Returns today's day + one year.
	    var d1 = Date.parse("next year");
	
	    ///////////////
	    // Date Math //
	    ///////////////
	
	    // Today + 2 days
	    var d1 = Date.parse("t+2");
	
	    // Today + 2 days
	    var d1 = Date.parse("today + 2 days");
	
	    // Today + 3 months
	    var d1 = Date.parse("t+3m");
	
	    // Today - 1 year
	    var d1 = Date.parse("today - 1 year");
	
	    // Today - 1 year
	    var d1 = Date.parse("t-1y"); 
	
	
	    /////////////////////////////
	    // Partial Dates and Times //
	    /////////////////////////////
	
	    // July 15th of this year.
	    var d1 = Date.parse("July 15");
	
	    // 15th day of current day and year.
	    var d1 = Date.parse("15");
	
	    // July 1st of current year at 10pm.
	    var d1 = Date.parse("7/1 10pm");
	    </code></pre>
	     *
	     * @param {String}   The string value to convert into a Date object [Required]
	     * @return {Date}    A Date object or null if the string cannot be converted into a Date.
	     */
	    $P.parse = function (s) {
	        var r = null; 
	        if (!s) { 
	            return null; 
	        }
	        if (s instanceof Date) {
	            return s;
	        }
	        try { 
	            r = $P.Grammar.start.call({}, s.replace(/^\s*(\S*(\s+\S+)*)\s*$/, "$1")); 
	        } catch (e) { 
	            return null; 
	        }
	        return ((r[1].length === 0) ? r[0] : null);
	    };
	
	    $P.getParseFunction = function (fx) {
	        var fn = $P.Grammar.formats(fx);
	        return function (s) {
	            var r = null;
	            try { 
	                r = fn.call({}, s); 
	            } catch (e) { 
	                return null; 
	            }
	            return ((r[1].length === 0) ? r[0] : null);
	        };
	    };
	    
	    /**
	     * Converts the specified string value into its JavaScript Date equivalent using the specified format {String} or formats {Array} and the CultureInfo specific format information.
	     * The format of the string value must match one of the supplied formats exactly.
	     * 
	     * Example
	    <pre><code>
	    // 15-Oct-2004
	    var d1 = Date.parseExact("10/15/2004", "M/d/yyyy");
	
	    // 15-Oct-2004
	    var d1 = Date.parse("15-Oct-2004", "M-ddd-yyyy");
	
	    // 15-Oct-2004
	    var d1 = Date.parse("2004.10.15", "yyyy.MM.dd");
	
	    // Multiple formats
	    var d1 = Date.parseExact("10/15/2004", ["M/d/yyyy", "MMMM d, yyyy"]);
	    </code></pre>
	     *
	     * @param {String}   The string value to convert into a Date object [Required].
	     * @param {Object}   The expected format {String} or an array of expected formats {Array} of the date string [Required].
	     * @return {Date}    A Date object or null if the string cannot be converted into a Date.
	     */
	    $P.parseExact = function (s, fx) { 
	        return $P.getParseFunction(fx)(s); 
	    };	
	}());

// #endregion
	
// #region *******************************      Sugarpak      *******************************
	
	/**
	 **************************************************************
	 ** SugarPak - Domain Specific Language -  Syntactical Sugar **
	 **************************************************************
	 */
 
	(function () {
	    var $D = Date, $P = $D.prototype, $C = $D.CultureInfo, $N = Number.prototype;
	
	    // private
	    $P._orient = +1;
	
	    // private
	    $P._nth = null;
	
	    // private
	    $P._is = false;
	
	    // private
	    $P._same = false;
	    
	    // private
	    $P._isSecond = false;
	
	    // private
	    $N._dateElement = "day";
	
	    /** 
	     * Moves the date to the next instance of a date as specified by the subsequent date element function (eg. .day(), .month()), month name function (eg. .january(), .jan()) or day name function (eg. .friday(), fri()).
	     * Example
	    <pre><code>
	    Date.today().next().friday();
	    Date.today().next().fri();
	    Date.today().next().march();
	    Date.today().next().mar();
	    Date.today().next().week();
	    </code></pre>
	     * 
	     * @return {Date}    date
	     */
	    $P.next = function () {
	        this._orient = +1;
	        return this;
	    };
	
	    /** 
	     * Creates a new Date (Date.today()) and moves the date to the next instance of the date as specified by the subsequent date element function (eg. .day(), .month()), month name function (eg. .january(), .jan()) or day name function (eg. .friday(), fri()).
	     * Example
	    <pre><code>
	    Date.next().friday();
	    Date.next().fri();
	    Date.next().march();
	    Date.next().mar();
	    Date.next().week();
	    </code></pre>
	     * 
	     * @return {Date}    date
	     */    
	    $P.next = function () {
	        return $P.today().next();
	    };
	
	    /** 
	     * Moves the date to the previous instance of a date as specified by the subsequent date element function (eg. .day(), .month()), month name function (eg. .january(), .jan()) or day name function (eg. .friday(), fri()).
	     * Example
	    <pre><code>
	    Date.today().last().friday();
	    Date.today().last().fri();
	    Date.today().last().march();
	    Date.today().last().mar();
	    Date.today().last().week();
	    </code></pre>
	     *  
	     * @return {Date}    date
	     */
	    $P.last = $P.prev = $P.previous = function () {
	        this._orient = -1;
	        return this;
	    };
	
	    /** 
	     * Creates a new Date (Date.today()) and moves the date to the previous instance of the date as specified by the subsequent date element function (eg. .day(), .month()), month name function (eg. .january(), .jan()) or day name function (eg. .friday(), fri()).
	     * Example
	    <pre><code>
	    Date.last().friday();
	    Date.last().fri();
	    Date.previous().march();
	    Date.prev().mar();
	    Date.last().week();
	    </code></pre>
	     *  
	     * @return {Date}    date
	     */
	    $P.last = $P.prev = $P.previous = function () {
	        return $P.today().last();
	    };    
	
	    /** 
	     * Performs a equality check when followed by either a month name, day name or .weekday() function.
	     * Example
	    <pre><code>
	    Date.today().is().friday(); // true|false
	    Date.today().is().fri();
	    Date.today().is().march();
	    Date.today().is().mar();
	    </code></pre>
	     *  
	     * @return {Boolean}    true|false
	     */
	    $P.is = function () { 
	        this._is = true; 
	        return this; 
	    };
	
	    /** 
	     * Determines if two date objects occur on/in exactly the same instance of the subsequent date part function.
	     * The function .same() must be followed by a date part function (example: .day(), .month(), .year(), etc).
	     *
	     * An optional Date can be passed in the date part function. If now date is passed as a parameter, 'Now' is used. 
	     *
	     * The following example demonstrates how to determine if two dates fall on the exact same day.
	     *
	     * Example
	    <pre><code>
	    var d1 = Date.today(); // today at 00:00
	    var d2 = new Date();   // exactly now.
	
	    // Do they occur on the same day?
	    d1.same().day(d2); // true
	    
	     // Do they occur on the same hour?
	    d1.same().hour(d2); // false, unless d2 hour is '00' (midnight).
	    
	    // What if it's the same day, but one year apart?
	    var nextYear = Date.today().add(1).year();
	
	    d1.same().day(nextYear); // false, because the dates must occur on the exact same day. 
	    </code></pre>
	     *
	     * Scenario: Determine if a given date occurs during some week period 2 months from now. 
	     *
	     * Example
	    <pre><code>
	    var future = Date.today().add(2).months();
	    return someDate.same().week(future); // true|false;
	    </code></pre>
	     *  
	     * @return {Boolean}    true|false
	     */    
	    $P.same = function () { 
	        this._same = true;
	        this._isSecond = false;
	        return this; 
	    };
	
	    /** 
	     * Determines if the current date/time occurs during Today. Must be preceded by the .is() function.
	     * Example
	    <pre><code>
	    someDate.is().today();    // true|false
	    new Date().is().today();  // true
	    Date.today().is().today();// true
	    Date.today().add(-1).day().is().today(); // false
	    </code></pre>
	     *  
	     * @return {Boolean}    true|false
	     */    
	    $P.today = function () {
	        return this.same().day();
	    };
	
	    /** 
	     * Determines if the current date is a weekday. This function must be preceded by the .is() function.
	     * Example
	    <pre><code>
	    Date.today().is().weekday(); // true|false
	    </code></pre>
	     *  
	     * @return {Boolean}    true|false
	     */
	    $P.weekday = function () {
	        if (this._is) { 
	            this._is = false;
	            return (!this.is().sat() && !this.is().sun());
	        }
	        return false;
	    };
	
	    /** 
	     * Sets the Time of the current Date instance. A string "6:15 pm" or config object {hour:18, minute:15} are accepted.
	     * Example
	    <pre><code>
	    // Set time to 6:15pm with a String
	    Date.today().at("6:15pm");
	
	    // Set time to 6:15pm with a config object
	    Date.today().at({hour:18, minute:15});
	    </code></pre>
	     *  
	     * @return {Date}    date
	     */
	    $P.at = function (time) {
	        return (typeof time === "string") ? $P.parse(this.toString("d") + " " + time) : this.set(time);
	    }; 
	        
	    /** 
	     * Creates a new Date() and adds this (Number) to the date based on the preceding date element function (eg. second|minute|hour|day|month|year).
	     * Example
	    <pre><code>
	    // Undeclared Numbers must be wrapped with parentheses. Requirment of JavaScript.
	    (3).days().fromNow();
	    (6).months().fromNow();
	
	    // Declared Number variables do not require parentheses. 
	    var n = 6;
	    n.months().fromNow();
	    </code></pre>
	     *  
	     * @return {Date}    A new Date instance
	     */
	    $N.fromNow = $N.after = function (date) {
	        var c = {};
	        c[this._dateElement] = this;
	        return ((!date) ? new Date() : date.clone()).add(c);
	    };
	
	    /** 
	     * Creates a new Date() and subtract this (Number) from the date based on the preceding date element function (eg. second|minute|hour|day|month|year).
	     * Example
	    <pre><code>
	    // Undeclared Numbers must be wrapped with parentheses. Requirment of JavaScript.
	    (3).days().ago();
	    (6).months().ago();
	
	    // Declared Number variables do not require parentheses. 
	    var n = 6;
	    n.months().ago();
	    </code></pre>
	     *  
	     * @return {Date}    A new Date instance
	     */
	    $N.ago = $N.before = function (date) {
	        var c = {};
	        c[this._dateElement] = this * -1;
	        return ((!date) ? new Date() : date.clone()).add(c);
	    };
	
	    // Do NOT modify the following string tokens. These tokens are used to build dynamic functions.
	    // All culture-specific strings can be found in the CultureInfo files. See /trunk/src/globalization/.
	    var dx = ("sunday monday tuesday wednesday thursday friday saturday").split(/\s/),
	        mx = ("january february march april may june july august september october november december").split(/\s/),
	        px = ("Millisecond Second Minute Hour Day Week Month Year").split(/\s/),
	        pxf = ("Milliseconds Seconds Minutes Hours Date Week Month FullYear").split(/\s/),
			nth = ("final first second third fourth fifth").split(/\s/),
	        de;
	
	   /** 
	     * Returns an object literal of all the date parts.
	     * Example
	    <pre><code>
		var o = new Date().toObject();
		
		// { year: 2008, month: 4, week: 20, day: 13, hour: 18, minute: 9, second: 32, millisecond: 812 }
		
		// The object properties can be referenced directly from the object.
		
		alert(o.day);  // alerts "13"
		alert(o.year); // alerts "2008"
	    </code></pre>
	     *  
	     * @return {Date}    An object literal representing the original date object.
	     */
	    $P.toObject = function () {
	        var o = {};
	        for (var i = 0; i < px.length; i++) {
	            o[px[i].toLowerCase()] = this["get" + pxf[i]]();
	        }
	        return o;
	    }; 
	   
	   /** 
	     * Returns a date created from an object literal. Ignores the .week property if set in the config. 
	     * Example
	    <pre><code>
		var o = new Date().toObject();
		
		return Date.fromObject(o); // will return the same date. 
	
	    var o2 = {month: 1, day: 20, hour: 18}; // birthday party!
	    Date.fromObject(o2);
	    </code></pre>
	     *  
	     * @return {Date}    An object literal representing the original date object.
	     */    
	    $P.fromObject = function(config) {
	        config.week = null;
	        return Date.today().set(config);
	    };
	        
	    // Create day name functions and abbreviated day name functions (eg. monday(), friday(), fri()).
	    var df = function (n) {
	        return function () { 
	            if (this._is) { 
	                this._is = false; 
	                return this.getDay() == n; 
	            }
	            if (this._nth !== null) {
	                // If the .second() function was called earlier, remove the _orient 
	                // from the date, and then continue.
	                // This is required because 'second' can be used in two different context.
	                // 
	                // Example
	                //
	                //   Date.today().add(1).second();
	                //   Date.march().second().monday();
	                // 
	                // Things get crazy with the following...
	                //   Date.march().add(1).second().second().monday(); // but it works!!
	                //  
	                if (this._isSecond) {
	                    this.addSeconds(this._orient * -1);
	                }
	                // make sure we reset _isSecond
	                this._isSecond = false;
	
	                var ntemp = this._nth;
	                this._nth = null;
	                var temp = this.clone().moveToLastDayOfMonth();
	                this.moveToNthOccurrence(n, ntemp);
	                if (this > temp) {
	                    throw new RangeError($P.getDayName(n) + " does not occur " + ntemp + " times in the month of " + $P.getMonthName(temp.getMonth()) + " " + temp.getFullYear() + ".");
	                }
	                return this;
	            }			
	            return this.moveToDayOfWeek(n, this._orient);
	        };
	    };
	    
	    var sdf = function (n) {
	        return function () {
	            var t = $P.today(), shift = n - t.getDay();
	            if (n === 0 && $C.firstDayOfWeek === 1 && t.getDay() !== 0) {
	                shift = shift + 7;
	            }
	            return t.addDays(shift);
	        };
	    };
		
	    for (var i = 0; i < dx.length; i++) {
	        // Create constant static Day Name variables. Example: Date.MONDAY or Date.MON
	        $P[dx[i].toUpperCase()] = $P[dx[i].toUpperCase().substring(0, 3)] = i;
	
	        // Create Day Name functions. Example: Date.monday() or Date.mon()
	        $P[dx[i]] = $P[dx[i].substring(0, 3)] = sdf(i);
	
	        // Create Day Name instance functions. Example: Date.today().next().monday()
	        $P[dx[i]] = $P[dx[i].substring(0, 3)] = df(i);
	    }
	    
	    // Create month name functions and abbreviated month name functions (eg. january(), march(), mar()).
	    var mf = function (n) { 
	        return function () {
	            if (this._is) { 
	                this._is = false; 
	                return this.getMonth() === n; 
	            }
	            return this.moveToMonth(n, this._orient); 
	        };
	    };
	    
	    var smf = function (n) {
	        return function () {
	            return $P.today().set({ month: n, day: 1 });
	        };
	    };
	    
	    for (var j = 0; j < mx.length; j++) {
	        // Create constant static Month Name variables. Example: Date.MARCH or Date.MAR
	        $P[mx[j].toUpperCase()] = $P[mx[j].toUpperCase().substring(0, 3)] = j;
	
	        // Create Month Name functions. Example: Date.march() or Date.mar()
	        $P[mx[j]] = $P[mx[j].substring(0, 3)] = smf(j);
	
	        // Create Month Name instance functions. Example: Date.today().next().march()
	        $P[mx[j]] = $P[mx[j].substring(0, 3)] = mf(j);
	    }
	    
	    // Create date element functions and plural date element functions used with Date (eg. day(), days(), months()).
	    var ef = function (j) {
	        return function () {
	            // if the .second() function was called earlier, the _orient 
	            // has alread been added. Just return this and reset _isSecond.
	            if (this._isSecond) {
	                this._isSecond = false;
	                return this;
	            }
	
	            if (this._same) {
	                this._same = this._is = false; 
	                var o1 = this.toObject(),
	                    o2 = (arguments[0] || new Date()).toObject(),
	                    v = "",
	                    k = j.toLowerCase();
	                    
	                for (var m = (px.length - 1); m > -1; m--) {
	                    v = px[m].toLowerCase();
	                    if (o1[v] != o2[v]) {
	                        return false;
	                    }
	                    if (k == v) {
	                        break;
	                    }
	                }
	                return true;
	            }
	            
	            if (j.substring(j.length - 1) != "s") {
	                j += "s"; 
	            }
	            return this["add" + j](this._orient);
	        };
	    };
	    
	    
	    var nf = function (n) {
	        return function () {
	            this._dateElement = n;
	            return this;
	        };
	    };
	   
	    for (var k = 0; k < px.length; k++) {
	        de = px[k].toLowerCase();
	    
	        // Create date element functions and plural date element functions used with Date (eg. day(), days(), months()).
	        $P[de] = $P[de + "s"] = ef(px[k]);
	        
	        // Create date element functions and plural date element functions used with Number (eg. day(), days(), months()).
	        $N[de] = $N[de + "s"] = nf(de);
	    }
	    
	    $P._ss = ef("Second");
		
	    var nthfn = function (n) {
	        return function (dayOfWeek) {
	            if (this._same) {
	                return this._ss(arguments[0]);
	            }
	            if (dayOfWeek || dayOfWeek === 0) {
	                return this.moveToNthOccurrence(dayOfWeek, n);
	            }
	            this._nth = n;
	
	            // if the operator is 'second' add the _orient, then deal with it later...
	            if (n === 2 && (dayOfWeek === undefined || dayOfWeek === null)) {
	                this._isSecond = true;
	                return this.addSeconds(this._orient);
	            }
	            return this;
	        };
	    };
	
	    for (var l = 0; l < nth.length; l++) {
	        $P[nth[l]] = (l === 0) ? nthfn(-1) : nthfn(l);
	    }
	}());

// #endregion

// #region *********************************      Time      *********************************

	/* 
	 * TimeSpan(milliseconds);
	 * TimeSpan(days, hours, minutes, seconds);
	 * TimeSpan(days, hours, minutes, seconds, milliseconds);
	 */
	var TimeSpan = function (days, hours, minutes, seconds, milliseconds) {
	    var attrs = "days hours minutes seconds milliseconds".split(/\s+/);
	    
	    var gFn = function (attr) { 
	        return function () { 
	            return this[attr]; 
	        }; 
	    };
		
	    var sFn = function (attr) { 
	        return function (val) { 
	            this[attr] = val; 
	            return this; 
	        }; 
	    };
		
	    for (var i = 0; i < attrs.length ; i++) {
	        var $a = attrs[i], $b = $a.slice(0, 1).toUpperCase() + $a.slice(1);
	        TimeSpan.prototype[$a] = 0;
	        TimeSpan.prototype["get" + $b] = gFn($a);
	        TimeSpan.prototype["set" + $b] = sFn($a);
	    }
	
	    if (arguments.length == 4) { 
	        this.setDays(days); 
	        this.setHours(hours); 
	        this.setMinutes(minutes); 
	        this.setSeconds(seconds); 
	    } else if (arguments.length == 5) { 
	        this.setDays(days); 
	        this.setHours(hours); 
	        this.setMinutes(minutes); 
	        this.setSeconds(seconds); 
	        this.setMilliseconds(milliseconds); 
	    } else if (arguments.length == 1 && typeof days == "number") {
	        var orient = (days < 0) ? -1 : +1;
	        this.setMilliseconds(Math.abs(days));
	        
	        this.setDays(Math.floor(this.getMilliseconds() / 86400000) * orient);
	        this.setMilliseconds(this.getMilliseconds() % 86400000);
	
	        this.setHours(Math.floor(this.getMilliseconds() / 3600000) * orient);
	        this.setMilliseconds(this.getMilliseconds() % 3600000);
	
	        this.setMinutes(Math.floor(this.getMilliseconds() / 60000) * orient);
	        this.setMilliseconds(this.getMilliseconds() % 60000);
	
	        this.setSeconds(Math.floor(this.getMilliseconds() / 1000) * orient);
	        this.setMilliseconds(this.getMilliseconds() % 1000);
	
	        this.setMilliseconds(this.getMilliseconds() * orient);
	    }
	
	    this.getTotalMilliseconds = function () {
	        return (this.getDays() * 86400000) + (this.getHours() * 3600000) + (this.getMinutes() * 60000) + (this.getSeconds() * 1000); 
	    };
	    
	    this.compareTo = function (time) {
	        var t1 = new Date(1970, 1, 1, this.getHours(), this.getMinutes(), this.getSeconds()), t2;
	        if (time === null) { 
	            t2 = new Date(1970, 1, 1, 0, 0, 0); 
	        }
	        else {
	            t2 = new Date(1970, 1, 1, time.getHours(), time.getMinutes(), time.getSeconds());
	        }
	        return (t1 < t2) ? -1 : (t1 > t2) ? 1 : 0;
	    };
	
	    this.equals = function (time) {
	        return (this.compareTo(time) === 0);
	    };    
	
	    this.add = function (time) { 
	        return (time === null) ? this : this.addSeconds(time.getTotalMilliseconds() / 1000); 
	    };
	
	    this.subtract = function (time) { 
	        return (time === null) ? this : this.addSeconds(-time.getTotalMilliseconds() / 1000); 
	    };
	
	    this.addDays = function (n) { 
	        return new TimeSpan(this.getTotalMilliseconds() + (n * 86400000)); 
	    };
	
	    this.addHours = function (n) { 
	        return new TimeSpan(this.getTotalMilliseconds() + (n * 3600000)); 
	    };
	
	    this.addMinutes = function (n) { 
	        return new TimeSpan(this.getTotalMilliseconds() + (n * 60000)); 
	    };
	
	    this.addSeconds = function (n) {
	        return new TimeSpan(this.getTotalMilliseconds() + (n * 1000)); 
	    };
	
	    this.addMilliseconds = function (n) {
	        return new TimeSpan(this.getTotalMilliseconds() + n); 
	    };
	
	    this.get12HourHour = function () {
	        return (this.getHours() > 12) ? this.getHours() - 12 : (this.getHours() === 0) ? 12 : this.getHours();
	    };
	
	    this.getDesignator = function () { 
	        return (this.getHours() < 12) ? Date.CultureInfo.amDesignator : Date.CultureInfo.pmDesignator;
	    };
	
	    this.toString = function (format) {
	        this._toString = function () {
	            if (this.getDays() !== null && this.getDays() > 0) {
	                return this.getDays() + "." + this.getHours() + ":" + this.p(this.getMinutes()) + ":" + this.p(this.getSeconds());
	            }
	            else { 
	                return this.getHours() + ":" + this.p(this.getMinutes()) + ":" + this.p(this.getSeconds());
	            }
	        };
	        
	        this.p = function (s) {
	            return (s.toString().length < 2) ? "0" + s : s;
	        };
	        
	        var me = this;
	        
	        return format ? format.replace(/dd?|HH?|hh?|mm?|ss?|tt?/g, 
	        function (format) {
	            switch (format) {
	            case "d":	
	                return me.getDays();
	            case "dd":	
	                return me.p(me.getDays());
	            case "H":	
	                return me.getHours();
	            case "HH":	
	                return me.p(me.getHours());
	            case "h":	
	                return me.get12HourHour();
	            case "hh":	
	                return me.p(me.get12HourHour());
	            case "m":	
	                return me.getMinutes();
	            case "mm":	
	                return me.p(me.getMinutes());
	            case "s":	
	                return me.getSeconds();
	            case "ss":	
	                return me.p(me.getSeconds());
	            case "t":	
	                return ((me.getHours() < 12) ? Date.CultureInfo.amDesignator : Date.CultureInfo.pmDesignator).substring(0, 1);
	            case "tt":	
	                return (me.getHours() < 12) ? Date.CultureInfo.amDesignator : Date.CultureInfo.pmDesignator;
	            }
	        }
	        ) : this._toString();
	    };
	    return this;
	};    
	
	/**
	 * Gets the time of day for this date instances. 
	 * @return {TimeSpan} TimeSpan
	 */
	Date.prototype.getTimeOfDay = function () {
	    return new TimeSpan(0, this.getHours(), this.getMinutes(), this.getSeconds(), this.getMilliseconds());
	};
	
	/* 
	 * TimePeriod(startDate, endDate);
	 * TimePeriod(years, months, days, hours, minutes, seconds, milliseconds);
	 */
	var TimePeriod = function (years, months, days, hours, minutes, seconds, milliseconds) {
	    var attrs = "years months days hours minutes seconds milliseconds".split(/\s+/);
	    
	    var gFn = function (attr) { 
	        return function () { 
	            return this[attr]; 
	        }; 
	    };
		
	    var sFn = function (attr) { 
	        return function (val) { 
	            this[attr] = val; 
	            return this; 
	        }; 
	    };
		
	    for (var i = 0; i < attrs.length ; i++) {
	        var $a = attrs[i], $b = $a.slice(0, 1).toUpperCase() + $a.slice(1);
	        TimePeriod.prototype[$a] = 0;
	        TimePeriod.prototype["get" + $b] = gFn($a);
	        TimePeriod.prototype["set" + $b] = sFn($a);
	    }
	    if (arguments.length == 7) { 
	        this.years = years;
	        this.months = months;
	        this.setDays(days);
	        this.setHours(hours); 
	        this.setMinutes(minutes); 
	        this.setSeconds(seconds); 
	        this.setMilliseconds(milliseconds);
	    } else if (arguments.length == 2 && arguments[0] instanceof Date && arguments[1] instanceof Date) {
	        // startDate and endDate as arguments
	    
	        var d1 = years.clone();
	        var d2 = months.clone();
	    
	        var temp = d1.clone();
	        var orient = (d1 > d2) ? -1 : +1;
	        
	        this.years = d2.getFullYear() - d1.getFullYear();
	        temp.addYears(this.years);
	        
	        if (orient == +1) {
	            if (temp > d2) {
	                if (this.years !== 0) {
	                    this.years--;
	                }
	            }
	        } else {
	            if (temp < d2) {
	                if (this.years !== 0) {
	                    this.years++;
	                }
	            }
	        }
	        
	        d1.addYears(this.years);
	
	        if (orient == +1) {
	            while (d1 < d2 && d1.clone().addDays(Date.getDaysInMonth(d1.getYear(), d1.getMonth()) ) < d2) {
	                d1.addMonths(1);
	                this.months++;
	            }
	        }
	        else {
	            while (d1 > d2 && d1.clone().addDays(-d1.getDaysInMonth()) > d2) {
	                d1.addMonths(-1);
	                this.months--;
	            }
	        }
	        
	        var diff = d2 - d1;
	
	        if (diff !== 0) {
	            var ts = new TimeSpan(diff);
	            this.setDays(ts.getDays());
	            this.setHours(ts.getHours());
	            this.setMinutes(ts.getMinutes());
	            this.setSeconds(ts.getSeconds());
	            this.setMilliseconds(ts.getMilliseconds());
	        }
	    }
	    return this;
	};

// #endregion
	
	]]>
	</script>

</component><component id="WUnderground">
	<comment>
		Weather Underground provider
	</comment>
	<registration description="Weather Underground Provider" progid="DXWeatherProvider.WUnderground" version="1" classid="{DFF07170-3A66-41e8-9685-67CC07173146}" />  
      	    	  
    <object id="m_locations" progid="Scripting.Dictionary" />  
    <object id="m_alerts" progid="Scripting.Dictionary" />  
    <object id="m_forecast" progid="Scripting.Dictionary" />  
    <object id="m_cameras" progid="Scripting.Dictionary" />  
    
    <object id="m_request" progid="Microsoft.XmlDom" /> 
	    
	<public>
		<property name="ID">
			<get />
		</property>
		
		<property name="Name">
			<get />
		</property>
		
		<property name="UseMetricSystem" internalName="m_useMetricSystem" />
		
		<method name="SetLicense">
			<parameter name="id" />
			<parameter name="key" />
		</method>
		
		<method name="RegisterCallbacks">
			<parameter name="locationCallback" />
			<parameter name="weatherCallback" />
			<parameter name="alertsCallback" />
			<parameter name="forecastCallback" />
			<parameter name="camerasCallback" />
			<parameter name="errorCallback" />
		</method>
		
		<method name="Abort" />
		
		<comment>
			Query can be one of the following:
				- zipcode (US or Canadian) 
				- city state; city, state 
				- city 
				- state 
				- country 
				- airport code (3-letter or 4-letter) 
				- lat,lon 
		</comment>
		<method name="GetLocations">
			<parameter name="locationQuery" />
		</method>

		<comment>
			Query can be one of the following:
				- airport code
				- location (ie. station) ID
		</comment>
		<method name="GetWeather">
			<parameter name="locationQuery" />
		</method>

		<comment>
			Query can be one of the following:
				- zipcode (US or Canadian) 
				- city state; city, state 
				- city 
				- state 
				- country 
				- airport code (3-letter or 4-letter) 
				- lat,lon 
		</comment>
		<method name="GetAlerts">
			<parameter name="locationQuery" />
		</method>

		<comment>
			Query can be one of the following:
				- zipcode (US or Canadian) 
				- city state; city, state 
				- city 
				- state 
				- country 
				- airport code (3-letter or 4-letter) 
				- lat,lon 
		</comment>
		<method name="GetForecast">
			<parameter name="locationQuery" />
		</method>
		
		<comment>
			Query can be one of the following:
				- zipcode (US or Canadian) 
				- city state; city, state 
				- city 
				- state 
				- country 
				- airport code (3-letter or 4-letter) 
				- lat,lon
		</comment>
		<method name="GetCameras">
			<parameter name="locationQuery" />
		</method>			
	</public>
	
	<resource id="provider_id">WUnderground</resource>
	<resource id="provider_name">Weather Underground</resource>
	<resource id="url_locations">http://api.wunderground.com/auto/wui/geo/GeoLookupXML/index.xml?query=</resource>
	<resource id="url_weather">http://api.wunderground.com/auto/wui/geo/WXCurrentObXML/index.xml?query=</resource>
	<resource id="url_station">http://api.wunderground.com/weatherstation/WXCurrentObXML.asp?ID=</resource>
	<resource id="url_alerts">http://api.wunderground.com/auto/wui/geo/AlertsXML/index.xml?query=</resource>
	<resource id="url_forecast">http://api.wunderground.com/auto/wui/geo/ForecastXML/index.xml?query=</resource>
	
	<script language="JScript">
	<![CDATA[
	
	//**Start Encode**
	
	var ErrorCode 			= getComponent("WeatherError");
	
	// Data
	var m_weather   		= null;
	var m_lastUpdateTime	= null;
	
	// Helper
	var m_helper			= getComponent("WeatherHelper");
	var m_dateHelper		= getComponent("DateEx");

	// callbacks
	var m_locationsCallback = null;
	var m_weatherCallback 	= null;
	var m_alertsCallback 	= null;
	var m_forecastCallback  = null;
	var m_camerasCallback   = null;
	var m_errorCallback 	= null;
	
	var m_useMetricSystem = true;
	
	///////////////////////////////
	// Properties
	///////////////////////////////
	function get_ID() {
		return getResource("provider_id");
	}
	
	function get_Name() {
		return getResource("provider_name");
	}	
	
	///////////////////////////////
	// Utilities
	///////////////////////////////
	function getComponent(id) {		
		return createComponent(id);
	}
	
	// Get a query string, using data in priority order
	function getQueryString(locationQuery) {
		
		// Check that location query is not null
		if (locationQuery == null)
			return "";
				
		if (locationQuery.CustomQueryString != "")
			return locationQuery.CustomQueryString;
		
		if (locationQuery.ZipCode != "")
			return locationQuery.ZipCode;
			
		if (locationQuery.City != "" && locationQuery.State != "")
			return locationQuery.City + ", " + locationQuery.State;
			
		if (locationQuery.City != "")
			return locationQuery.City;
			
		if (locationQuery.State != "")
		 	return locationQuery.State;
		 	
		if (locationQuery.Country != "")
			return locationQuery.Country;
			
		if (locationQuery.AirportCode != "")
			return locationQuery.AirportCode;
			
		if (locationQuery.Latitude != "" && locationQuery.Longitude != "")
			return locationQuery.Latitude + "," + locationQuery.Longitude;
			
		return "";		
	}
	
	// Get a query string for the weather info (airport code / id only)
	function getWeatherQueryString(locationQuery)
	{		
		// Check that location query is not null
		if (locationQuery == null)
			return "";
			
		if (locationQuery.AirportCode != "")
			return getResource("url_weather") + locationQuery.AirportCode;
		
		if (locationQuery.ID != "")
			return getResource("url_station") + locationQuery.ID;
		
		return "";
	}

	///////////////////////////////
	// Misc parsing functions
	///////////////////////////////	
	
	// Parse elevation string and remove unit at the end / convert to metric system if needed
	function parseElevation(elevation)
	{
		// FIXME: remove "ft" at the end of the elevation data and Trim the string
		return m_helper.Trim(elevation);
	}
	
	// Parse humidity string and remove % at the end
	function parseHumidity(humidity)
	{
		// FIXME: remove "%" at the end if present
		return m_helper.Trim(humidity);
	}
	
	// Parse speed string, remove unit at the end / convert to metric system if needed
	function parseSpeed(speed)
	{
		// FIXME: remove "mph" at the end if present, and convert to metric if needed
		return m_helper.Trim(speed);
	}
	
	// Parse speed heat/windchill
	function parseHeat(heat)
	{
		var trimmed = m_helper.Trim(heat);
		
		if (heat == "NA")
			return "";
			
		return heat;
	}
	
	// Parse weather code and return a code number
	function parseCode(code)
	{
		// FIXME: convert from string code to weather icon number
		return m_helper.Trim(code);
	}	
	
	///////////////////////////////
	// Public functions
	///////////////////////////////
	
	// Setup license
	function SetLicense(id, key) {
		// Not used by this provider: always return E_OK
		return ErrorCode.E_OK;
	}
	
	// Set callbacks
	function RegisterCallbacks(locationsCallback, weatherCallback, alertsCallback, forecastCallback, camerasCallback, errorCallback) {
		m_locationsCallback = locationsCallback;
		m_weatherCallback 	= weatherCallback;
		m_alertsCallback 	= alertsCallback;
		m_forecastCallback  = forecastCallback;
		m_camerasCallback   = camerasCallback;
		m_errorCallback 	= errorCallback;
	}
	
	// Abort current request
	function Abort()
	{
		m_request.abort();
	}
	
	/////////////////////////////////////////////////////////////////////////////////////////////////////
	// Get a list of locations
	/////////////////////////////////////////////////////////////////////////////////////////////////////
	function GetLocations(locationQuery) {
		// Check query for validity
		if (getQueryString(locationQuery) == "")
			return ErrorCode.E_NOTAVAILABLE;
		
		// Reset DOM
		m_request.abort();
		
		m_request.onreadystatechange = OnLocationsResponse;
		m_request.async = true;
		m_request.load(getResource("url_locations") + getQueryString(locationQuery));
		
		return ErrorCode.E_OK;		
	}
	
	function OnLocationsResponse() {
		if (m_request.readyState != 4) 
			return;
			
		if (!m_helper.CheckParserError(m_request, m_errorCallback, ErrorCode))
			return;
			
		// Clear any previous results
		m_locations.RemoveAll();	
		
		// locations index
		var i = 0;
		
		// Check if we got an intermediate list and parse it
		var locations = m_request.getElementsByTagName("locations");
		if (locations.length != 0) {
			
			debugger;
			
			var locationsEnumerator = new Enumerator(locations[0].getElementsByTagName("location"));		
			for (var enumerator = locationsEnumerator; !enumerator.atEnd(); enumerator.moveNext()) 
			{						
			    var entry = enumerator.item();
			    var city = getComponent("WeatherLocation");
			    
			    // we have no way to determine wether the second part is a state or a country,
			    // so we use the CustomQueryString property    
			    
			    // TODO if type == CITY, this is a US city and the second part is a state
			    // for INTLCITY, we cannot say whether this is a state or a country (ex: London, Ontario => in Canada)
			    city.CustomQueryString =  m_helper.GetNodeValue(entry, "name/text()");				  
			    
			    m_locations.Add(i, city);		    
			    i++;
			}
			
			m_locationsCallback(m_locations);
			return;
		}
				
			
		// Get the weather stations
		var stations = m_request.getElementsByTagName("nearby_weather_stations");
		if (stations.length == 0) {
			m_locationsCallback(m_locations);
			return;
		}
			
		// List airports
		var airportNode = stations[0].getElementsByTagName("airport");
		if (airportNode.length == 0) {
			m_locationsCallback(m_locations);
			return;
		}	
		
		var airportEnumerator = new Enumerator(airportNode[0].getElementsByTagName("station"));		
		for (var enumerator = airportEnumerator; !enumerator.atEnd(); enumerator.moveNext()) 
		{						
		    var entry = enumerator.item();
		    var airport = getComponent("WeatherLocation");
		    
		    airport.City 		 = m_helper.GetNodeValue(entry, "city/text()");	
		    airport.State  		 = m_helper.GetNodeValue(entry, "state/text()");	
		    airport.Country 	 = m_helper.GetNodeValue(entry, "country/text()");	
		    airport.AirportCode  = m_helper.GetNodeValue(entry, "icao/text()");	
		    airport.Latitude 	 = m_helper.GetNodeValue(entry, "lat/text()");	
		    airport.Longitude    = m_helper.GetNodeValue(entry, "lon/text()");			    
		    
		    m_locations.Add(i, airport);		    
		    i++;
		}
		
		// List personal weather stations
		var personalStations = stations[0].getElementsByTagName("pws");
		if (personalStations.length == 0) {
			m_locationsCallback(m_locations);
			return;
		}
			
		var pwsEnumerator = new Enumerator(personalStations[0].getElementsByTagName("station"));		
		for (var enumerator = pwsEnumerator; !enumerator.atEnd(); enumerator.moveNext()) 
		{						
		    var entry = enumerator.item();
		    var pws = getComponent("WeatherLocation");
		    
		    pws.Name	  = m_helper.GetNodeValue(entry, "neighborhood/text()");	
		    pws.City 	  = m_helper.GetNodeValue(entry, "city/text()");	
		    pws.State  	  = m_helper.GetNodeValue(entry, "state/text()");	
		    pws.Country   = m_helper.GetNodeValue(entry, "country/text()");	
		    pws.ID  	  = m_helper.GetNodeValue(entry, "id/text()");	
		    
		    if (m_useMetricSystem)
		    	pws.Distance  = m_helper.GetNodeValue(entry, "distance_km/text()");			    
		    else
		    	pws.Distance  = m_helper.GetNodeValue(entry, "distance_mi/text()");
		    
		    m_locations.Add(i, pws);		    
		    i++;
		}
		
		m_locationsCallback(m_locations);
	}
	
	/////////////////////////////////////////////////////////////////////////////////////////////////////	
	// Get the current weather
	/////////////////////////////////////////////////////////////////////////////////////////////////////
	function GetWeather(locationQuery) {				
		// Check query for validity
		if (getWeatherQueryString(locationQuery) == "")
			return ErrorCode.E_NOTAVAILABLE;
					
		// Reset DOM
		m_request.abort();
		
		m_request.onreadystatechange = OnWeatherResponse;
		m_request.async = true;
		m_request.load(getWeatherQueryString(locationQuery));
		
		return ErrorCode.E_OK;		
	}
	
	function OnWeatherResponse() {
		if (m_request.readyState != 4) 
			return;
			
		if (!m_helper.CheckParserError(m_request, m_errorCallback, ErrorCode))
			return;

		// Reset weather object
		m_weather = null;
		m_weather = getComponent("WeatherInfo");
			
		// Parse weather
		var observation = m_request.selectNodes("current_observation");
		if (observation.length == 0) {
			m_weatherCallback(m_weather);	
			return;
		}
		
		// Set unit system
		m_weather.UseMetricSystem = m_useMetricSystem;
		
		///////////////////////////
		//  Parse location data  //
		///////////////////////////
		
		// Check that station ID is not empty
		var station_id = m_helper.GetNodeValue(observation[0], "station_id/text()");
		if (station_id == "")
		{
			m_errorCallback(ErrorCode.E_ERROR, "Response is empty. Please check that the station code you used is valid!");
			return;
		}		
		
		// Airport location
		var location = observation[0].getElementsByTagName("display_location");
		if (location.length != 0) {
			
			m_weather.Location = getComponent("WeatherLocation");
			
			m_weather.Location.City  	 = m_helper.GetNodeValue(location[0], "city/text()");		
			m_weather.Location.State	 = m_helper.GetNodeValue(location[0], "state_name/text()");		
			m_weather.Location.Country   = m_helper.GetNodeValue(location[0], "country/text()");		
			m_weather.Location.ZipCode   = m_helper.GetNodeValue(location[0], "zip/text()");		
			m_weather.Location.Latitude  = m_helper.GetNodeValue(location[0], "latitude/text()");		
			m_weather.Location.Longitude = m_helper.GetNodeValue(location[0], "longitude/text()");		
						
			m_weather.Location.Elevation = parseElevation(m_helper.GetNodeValue(location[0], "elevation/text()"));
			
			// Station ID goes into the location airport code
			m_weather.Location.AirportCode = station_id;
		} 
		
		// Personal weather station
		location = observation[0].getElementsByTagName("location");
		if (location.length != 0) {
			
			m_weather.Location = getComponent("WeatherLocation");
			
			m_weather.Location.Name 	 = m_helper.GetNodeValue(location[0], "neighborhood/text()");		
			m_weather.Location.City  	 = m_helper.GetNodeValue(location[0], "city/text()");		
			m_weather.Location.State	 = m_helper.GetNodeValue(location[0], "state/text()");					
			m_weather.Location.ZipCode   = m_helper.GetNodeValue(location[0], "zip/text()");		
			m_weather.Location.Latitude  = m_helper.GetNodeValue(location[0], "latitude/text()");		
			m_weather.Location.Longitude = m_helper.GetNodeValue(location[0], "longitude/text()");		
						
			m_weather.Location.Elevation = parseElevation(m_helper.GetNodeValue(location[0], "elevation/text()"));				
			
			// Station ID goes into the location ID
			m_weather.Location.ID        =  station_id;
		}
		
		//////////////////////////
		//  Parse weather data  //
		//////////////////////////
		
		// Use credit name as a weather station name
		m_weather.Station		  = m_helper.GetNodeValue(observation[0], "credit/text()");
		m_weather.Type 			  = m_helper.GetNodeValue(observation[0], "station_type/text()");
		
		// Observation date
		m_weather.Date = m_dateHelper.FromEpoch(m_helper.GetNodeValue(observation[0],  "observation_epoch/text()"));
		
		// Temperature
		if (m_useMetricSystem)
			m_weather.Temperature = m_helper.GetNodeValue(observation[0], "temp_c/text()");
		else
			m_weather.Temperature = m_helper.GetNodeValue(observation[0], "temp_f/text()");
			
		// Humidity
		m_weather.Humidity 		  = parseHumidity(m_helper.GetNodeValue(observation[0], "relative_humidity/text()"));
		
		// Wind
		m_weather.WindDescription = m_helper.GetNodeValue(observation[0], "wind_string/text()");
		m_weather.WindDirection   = m_helper.GetNodeValue(observation[0], "wind_dir/text()");
		m_weather.WindDegrees 	  = m_helper.GetNodeValue(observation[0], "wind_degrees/text()");
		m_weather.WindSpeed		  = parseSpeed(m_helper.GetNodeValue(observation[0], "wind_mph/text()"));
		m_weather.WindGust 		  = parseSpeed(m_helper.GetNodeValue(observation[0], "wind_gust_mph/text()"));
	    
	    // Pressure
	    if (m_useMetricSystem)
	    	m_weather.Pressure	  = m_helper.GetNodeValue(observation[0], "pressure_mb/text()");
	    else
	    	m_weather.Pressure	  = m_helper.GetNodeValue(observation[0], "pressure_in/text()");
	    	
	    // Dew Point
	    m_weather.DewPointDescription = m_helper.GetNodeValue(observation[0], "dewpoint_string/text()");
	    if (m_useMetricSystem)
	    	m_weather.DewPoint	  = m_helper.GetNodeValue(observation[0], "dewpoint_c/text()");
	    else
	    	m_weather.DewPoint	  = m_helper.GetNodeValue(observation[0], "dewpoint_f/text()");
	    	
	    // Heat index
	    m_weather.HeatDescription = parseHeat(m_helper.GetNodeValue(observation[0], "heat_index_string/text()"));
		if (m_useMetricSystem)
	    	m_weather.HeatIndex	  = parseHeat(m_helper.GetNodeValue(observation[0], "heat_index_c/text()"));
	    else
	    	m_weather.HeatIndex	  = parseHeat(m_helper.GetNodeValue(observation[0], "heat_index_f/text()"));			
	    	
	    // Solar Radiation & UV	
	    m_weather.SolarRadiation  = m_helper.GetNodeValue(observation[0], "solar_radiation/text()");			
	    m_weather.UV	  		  = m_helper.GetNodeValue(observation[0], "UV/text()");			
	    	
	    // Wind chill
	    m_weather.WindChillDescription = parseHeat(m_helper.GetNodeValue(observation[0], "windchill_string/text()"));
		if (m_useMetricSystem)
	    	m_weather.WindChill	  = parseHeat(m_helper.GetNodeValue(observation[0], "windchill_c/text()"));
	    else
	    	m_weather.WindChill	  = parseHeat(m_helper.GetNodeValue(observation[0], "windchill_f/text()"));		
	    		    
	    // Visibility
	    if (m_useMetricSystem)
	    	m_weather.Visibility  = m_helper.GetNodeValue(observation[0], "visibility_km/text()");
	    else
	    	m_weather.Visibility  = m_helper.GetNodeValue(observation[0], "visibility_mi/text()");
	    		    	
	    // Weather code
	    m_weather.Code    		  = parseCode(m_helper.GetNodeValue(observation[0], "icon/text()"));
	    
	    // Precipitation
		if (m_useMetricSystem) {
	    	m_weather.Precipitation1H     = m_helper.GetNodeValue(observation[0], "precip_1hr_metric/text()");
	    	m_weather.PrecipitationToday  = m_helper.GetNodeValue(observation[0], "precip_today_metric/text()");	    	
	    } else {
	    	m_weather.Precipitation1H     = m_helper.GetNodeValue(observation[0], "precip_1hr_in/text()");
	    	m_weather.PrecipitationToday  = m_helper.GetNodeValue(observation[0], "precip_today_in/text()");	    
	    }
	    
	    //////////////////////////////
		//  Parse links to website  //
		//////////////////////////////		
		var links = getComponent("WeatherLinks");
		
		links.Current			 = m_helper.GetNodeValue(observation[0], "ob_url/text()");
		links.Forecast		 	 = m_helper.GetNodeValue(observation[0], "forecast_url/text()");
		links.History			 = m_helper.GetNodeValue(observation[0], "history_url/text()");
		links.Credit			 = m_helper.GetNodeValue(observation[0], "credit_URL/text()");
		links.Logo				 = m_helper.GetNodeValue(observation[0], "ob_url/text()");
		
		m_weather.Links = links;
	    	
		m_weatherCallback(m_weather);	
	}

	/////////////////////////////////////////////////////////////////////////////////////////////////////		
	// Get a list of alerts
	/////////////////////////////////////////////////////////////////////////////////////////////////////
	function GetAlerts(locationQuery) {
		
		// Check query for validity
		if (getQueryString(locationQuery) == "")
			return ErrorCode.E_NOTAVAILABLE;
		
		// Reset DOM
		m_request.abort();
		
		m_request.onreadystatechange = OnAlertsResponse;
		m_request.async = true;
		m_request.load(getResource("url_alerts") + getQueryString(locationQuery));
		
		return ErrorCode.E_OK;		
	}
	
	function OnAlertsResponse() {
		if (m_request.readyState != 4) 
			return;
			
		if (!m_helper.CheckParserError(m_request, m_errorCallback, ErrorCode))
			return;

		// Clear any previous results
		m_alerts.RemoveAll();
		
		// Parse alert data
		var i = 0;
		var entryEnumerator = new Enumerator(m_request.getElementsByTagName("AlertItem"));		
		for (var enumerator = entryEnumerator; !enumerator.atEnd(); enumerator.moveNext()) 
		{						
		    var entry = enumerator.item();
		    var alert = getComponent("WeatherAlert");
		    
		    alert.Type 		   = m_helper.GetNodeValue(entry, "type/text()");	
		    alert.Description  = m_helper.GetNodeValue(entry, "description/text()");	
		    
		    alert.Date 		   = m_dateHelper.FromEpoch(m_helper.GetNodeValue(entry, "date/@epoch/text()"));	
		    alert.Expiration   = m_dateHelper.FromEpoch(m_helper.GetNodeValue(entry, "expires/@epoch/text()"));
		    	
		    alert.Message 	   = m_helper.GetNodeValue(entry, "message/text()");	
		    alert.Phenomena    = m_helper.GetNodeValue(entry, "phenomena/text()");	
		    alert.Significance = m_helper.GetNodeValue(entry, "significance/text()");	
		    
		    m_alerts.Add(i, alert);		    
		    i++;
		}
		
		m_alertsCallback(m_alerts);		
	}
	
	/////////////////////////////////////////////////////////////////////////////////////////////////////	
	// Get the forecast
	/////////////////////////////////////////////////////////////////////////////////////////////////////
	function GetForecast(locationQuery) {				
		// Check query for validity
		if (getQueryString(locationQuery) == "")
			return ErrorCode.E_NOTAVAILABLE;
		
		// Reset DOM
		m_request.abort();
		
		m_request.onreadystatechange = OnForecastResponse;
		m_request.async = true;
		m_request.load(getResource("url_forecast") + getQueryString(locationQuery));
		
		return ErrorCode.E_OK;	
	}
	
	function OnForecastResponse() {
		if (m_request.readyState != 4) 
			return;
			
		if (!m_helper.CheckParserError(m_request, m_errorCallback, ErrorCode))
			return;

		// Clear any previous results
		m_forecast.RemoveAll();
			
		// forecast index
		var i = 0;	
		
		// FIXME: merge forecast text & forecast into the first x objects
		//  we need to check the forecast number to now where to put things
		
		// Parse text forecast (today / tonight)
		var text_forecast = m_request.selectNodes("forecast/txt_forecast");
		if (text_forecast.length != 0) {
			
			var date = m_dateHelper.GetDate().parseExact(m_helper.GetNodeValue(text_forecast[0], "date/text()"), ["h:mm tt Z", "h:mm tt"]);		
			
			var textforecastEnumerator = new Enumerator(text_forecast[0].getElementsByTagName("forecastday"));
			for (var enumerator = textforecastEnumerator; !enumerator.atEnd(); enumerator.moveNext()) 
			{		
			    var entry = enumerator.item();
			    var forecast = getComponent("WeatherInfo");
				
				// Description
			    forecast.Description = m_helper.GetNodeValue(entry, "title/text()");
			    
			    // Weather code
	   			forecast.Code     = parseCode(m_helper.GetNodeValue(entry, "icon/text()"));
				
				// Forecast text
				forecast.ForecastDescription = m_helper.GetNodeValue(entry, "fcttext/text()");
				
				// Set day part
				if (forecast.Description == "Today")
					forecast.DayPart = forecast.DAY_PART_DAY;
				
				if (forecast.Description.search("Tonight") != -1)
					forecast.DayPart = forecast.DAY_PART_NIGHT;
									
				forecast.Date = date;
			    			    
			  	m_forecast.Add(i, forecast);    
			    i++;
			}
		}			
		
		// Parse detailed forecast
		var forecastNode = m_request.selectNodes("forecast/simpleforecast");
		if (forecastNode.length != 0) {
			
			var forecastEnumerator = new Enumerator(forecastNode[0].getElementsByTagName("forecastday"));
			for (var enumerator = forecastEnumerator; !enumerator.atEnd(); enumerator.moveNext()) 
			{						
			    var entry = enumerator.item();
			    var forecast = getComponent("WeatherInfo");
			    
			    // Description
			    forecast.Description = m_helper.GetNodeValue(entry, "conditions/text()");
			    
			    // Weather code
	   			forecast.Code     = parseCode(m_helper.GetNodeValue(entry, "icon/text()"));
			    			    			   
			    // High & Low
			    if (m_useMetricSystem) {
			    	forecast.ForecastHigh		= m_helper.GetNodeValue(entry, "high/celsius/text()");
			    	forecast.ForecastLow		= m_helper.GetNodeValue(entry, "low/celsius/text()");	    	
			    } else {
			    	forecast.ForecastHigh		= m_helper.GetNodeValue(entry, "high/fahrenheit/text()");
			    	forecast.ForecastLow		= m_helper.GetNodeValue(entry, "low/fahrenheit/text()");	
			    }
			    
			    // Date
			    forecast.Date = m_dateHelper.FromEpoch(m_helper.GetNodeValue(entry, "date/epoch/text()"));			    
			    
			    m_forecast.Add(i, forecast);		    
			    i++;
			}
		}

		// Parse moon phase (insert in first forecast)
		var moon_phase = m_request.selectNodes("forecast/moon_phase");
		if (moon_phase.length != 0)
		{
			// Get the first forecast
			var forecast = m_forecast.Item(0);			
			if (forecast == null)
				forecast = getComponent("WeatherInfo");
				
			// Update Moon info
			forecast.MoonIlluminated 		 = m_helper.GetNodeValue(moon_phase[0], "percentIlluminated/text()"); 
			forecast.MoonAge				 = m_helper.GetNodeValue(moon_phase[0], "ageOfMoon/text()");
			
			// Sunrise / Sunset times
			var sunrise_hour 				 = m_helper.GetNodeValue(moon_phase[0], "sunrise/hour/text()");
			var sunrise_minute 				 = m_helper.GetNodeValue(moon_phase[0], "sunrise/minute/text()");
			var sunset_hour 				 = m_helper.GetNodeValue(moon_phase[0], "sunset/hour/text()")
			var sunset_minute 				 = m_helper.GetNodeValue(moon_phase[0], "sunset/minute/text()")
			
			if (sunrise_hour != "" && sunrise_minute != "")
				forecast.Sunrise = m_dateHelper.GetDate().set({ 
									 hour: parseInt(sunrise_hour),
									 minute: parseInt(sunrise_minute)});
								 
			if (sunset_hour != "" && sunset_minute != "")
				forecast.Sunset = m_dateHelper.GetDate().set({ 
									 hour: parseInt(sunset_hour),
									 minute: parseInt(sunset_minute)});
			
			m_forecast.Item(0) = forecast;		
		}
		
			
		m_forecastCallback(m_forecast);		
	}
	
	/////////////////////////////////////////////////////////////////////////////////////////////////////	
	// Get a list of cameras
	/////////////////////////////////////////////////////////////////////////////////////////////////////
	function GetCameras(locationQuery) {
		// TODO we should cache results from GetLocations and only make a new call if the query differs.		
		return ErrorCode.E_NOTIMPLEMENTED;
	}	
	
	
	]]>
	</script>

</component><component id="TWC">
	<comment>
		The Weather Channel Provider
		
		Use is restricted. Please see the License Agreement in Docs/Weather.com"		
		You will need valid licensing information to be able to use this provider.
	</comment>
	<registration description="The Weather Channel Provider" progid="DXWeatherProvider.TWC" version="1" classid="{06FF483D-9278-4720-A58D-233581196FE7}" />  
      	    	  
	<object id="m_locations" progid="Scripting.Dictionary" />   
	<object id="m_weather" progid="Scripting.Dictionary" />   
    <object id="m_forecast" progid="Scripting.Dictionary" />      
    
    <object id="m_request" progid="Microsoft.XmlDom" /> 
	    
	<public>
		<property name="ID">
			<get />
		</property>
		
		<property name="Name">
			<get />
		</property>
		
		<property name="UseMetricSystem" internalName="m_useMetricSystem" />
		
		<method name="SetLicense">
			<parameter name="id" />
			<parameter name="key" />
		</method>
		
		<method name="RegisterCallbacks">
			<parameter name="locationCallback" />
			<parameter name="weatherCallback" />
			<parameter name="alertsCallback" />
			<parameter name="forecastCallback" />
			<parameter name="camerasCallback" />
			<parameter name="errorCallback" />
		</method>
		
		<method name="Abort" />
		
		<comment>
			Query can be one of the following:
				- Name
				- City
				- City, State
				- City, Country
				- Zip Code
		</comment>
		<method name="GetLocations">
			<parameter name="locationQuery" />
		</method>

		<comment>
			Query can be one of the following:
				- ID
		</comment>
		<method name="GetWeather">
			<parameter name="locationQuery" />
		</method>

		<comment>
			Not implemented in this provider
		</comment>
		<method name="GetAlerts">
			<parameter name="locationQuery" />
		</method>

		<comment>
			Query can be one of the following:
				- ID
		</comment>
		<method name="GetForecast">
			<parameter name="locationQuery" />
		</method>
		
		<comment>
			Not implemented in this provider
		</comment>
		<method name="GetCameras">
			<parameter name="locationQuery" />
		</method>			
	
	</public>
	
	<resource id="provider_id">TWC</resource>
	<resource id="provider_name">Weather.com</resource>
	
	<comment>
		Refresh rate in minutes
	</comment>
	<resource id="refresh_weather">25</resource>
	<resource id="refresh_forecast">210</resource>
	
	<resource id="url_locations">http://xoap.weather.com/search/search?where=</resource>
	<resource id="url_weather">http://xoap.weather.com/weather/local/</resource>
		
	<script language="JScript">
	<![CDATA[
	
	//**Start Encode**	
	
	var ErrorCode 			= getComponent("WeatherError");
	
	// Helper
	var m_helper			= getComponent("WeatherHelper");
	var m_dateHelper		= getComponent("DateEx");

	// callbacks
	var m_locationsCallback = null;
	var m_weatherCallback 	= null;
	var m_alertsCallback 	= null;
	var m_forecastCallback  = null;
	var m_camerasCallback   = null;
	var m_errorCallback 	= null;
	
	// License info
	var m_id = "";
	var m_key = "";
	
	var m_useMetricSystem = true;
	
	///////////////////////////////
	// Properties
	///////////////////////////////
	function get_ID() {
		return getResource("provider_id");
	}
	
	function get_Name() {
		return getResource("provider_name");
	}
	
	///////////////////////////////
	// Utilities
	///////////////////////////////
	function getComponent(id) {		
		return createComponent(id);
	}
	
	///////////////////////////////
	// Query
	///////////////////////////////
	function getLocationQueryString(query)
	{
		// Check that location query is not null
		if (query == null)
			return "";
			
		if (query.CustomQueryString != "")
			return query.CustomQueryString;	
						
		if (query.ZipCode != "")
			return query.ZipCode;
			
		if (query.City != "" && query.State != "")
			return query.City + ", " + query.State;
			
		if (query.City != ""  && query.Country != "")
			return query.City + ", " + query.Country;
			
		if (query.City != "")
		 	return query.City;			
			
		return "";
	}
	
	function getQueryString(queryLocation, isForecast)
	{
		// Check that location query is not null
		if (queryLocation == null || queryLocation.ID == "")
			return "";

		var query = getResource("url_weather");
		
		query += queryLocation.ID;
		
		if (isForecast)
			query += "?dayf=5";	// 5 day forecast
		else
			query += "?cc=*";	// current conditions
	
		query += "&link=xoap&prod=xoap";
	
		// Partner id & key
		query += "&par=" + m_id + "&key=" + m_key;
		
		if (m_useMetricSystem)
			query += "&unit=m";

		return query;
	}
	
	function checkFeedError()
	{
		// Check if this is an error message
		var error = m_request.selectNodes("error");
		if (error.length == 0)			
			return false;
			
		// Get err node
		var msg = m_request.getElementsByTagName("err");
		if (msg.length == 0) {
			m_errorCallback(ErrorCode.E_ERROR, "The provider returned an error!");
			return true;
		}
		
		// Get message
		var type	 = m_helper.GetNodeValue(msg[0], "@type/text()");	
		var message  = m_helper.GetNodeValue(msg[0], "text()");	
		
		m_errorCallback(ErrorCode.E_ERROR, "The provider returned an error: " + message + "(" + type + ")");
		
		return true;		
	}
	
	function parseLinks()
	{
		// Get the promo links node
		var promo = m_request.selectNodes("weather/lnks");
		if (promo.length == 0)
			return null;
			
		// Check link type: if anything else than prmo, throw an error
		var type = m_helper.GetNodeValue(promo[0], "@type/text()");
		if (type != "prmo")
		{
			m_errorCallback(ErrorCode.E_PARSERERROR, "Unknow type of link encoutered: " + type);
			return null;
		}			
			
		var links = getComponent("WeatherLinks");

		var promoEnumerator = new Enumerator(promo[0].getElementsByTagName("link"));		
		for (var enumerator = promoEnumerator; !enumerator.atEnd(); enumerator.moveNext()) 
		{						
		    var entry = enumerator.item();
		
			var title = m_helper.GetNodeValue(entry, "t/text()");
			var url   = m_helper.GetNodeValue(entry, "l/text()");
			
			links.Promo.Add(title, url);
		}
		
		if (links.Promo.Count == 0) // no link added!
			return null;
			
		return links;		
	}
	
	function parseCode(code)
	{
		// TODO parse code
		return code;
	}
	
	function parseCodeMoon(code)
	{
		// TODO parse code
		return code;
	}
	
	///////////////////////////////
	// Public functions
	///////////////////////////////
	
	// Setup license
	function SetLicense(id, key) {			
		if (id == "" || key == "")
			return ErrorCode.E_INVALIDLICENSE;
		
		m_id = id;
		m_key = key;	
		
		return ErrorCode.E_OK;
	}
	
	// Set callbacks
	function RegisterCallbacks(locationsCallback, weatherCallback, alertsCallback, forecastCallback, camerasCallback, errorCallback) {
		m_locationsCallback = locationsCallback;
		m_weatherCallback 	= weatherCallback;
		m_alertsCallback 	= alertsCallback;
		m_forecastCallback  = forecastCallback;
		m_camerasCallback   = camerasCallback;
		m_errorCallback 	= errorCallback;
	}
	
	// Abort current request
	function Abort()
	{
		m_request.abort();
	}
	
	/////////////////////////////////////////////////////////////////////////////////////////////////////
	// Get a list of locations
	/////////////////////////////////////////////////////////////////////////////////////////////////////
	function GetLocations(locationQuery) {
		// Check query for validity
		if (getLocationQueryString(locationQuery) == "")
			return ErrorCode.E_NOTAVAILABLE;
		
		// Reset dom
		m_request.abort();
		
		m_request.onreadystatechange = OnLocationsResponse;
		m_request.async = true;
		m_request.load(getResource("url_locations") + getLocationQueryString(locationQuery));
		
		return ErrorCode.E_OK;		
	}
	
	function OnLocationsResponse() {
		if (m_request.readyState != 4) 
			return;
			
		if (!m_helper.CheckParserError(m_request, m_errorCallback, ErrorCode))
			return;
			
		if (checkFeedError())
			return;
			
		// Clear any previous results (we do not cache location searchs)
		m_locations.RemoveAll();
		
		// Get search node
		var search = m_request.getElementsByTagName("search");
		if (search.length == 0) {
			m_errorCallback(ErrorCode.E_ERROR, "No search results!");
			return;
		}
		
		var i = 0;				
		var locationEnumerator = new Enumerator(search[0].getElementsByTagName("loc"));		
		for (var enumerator = locationEnumerator; !enumerator.atEnd(); enumerator.moveNext()) 
		{						
		    var entry = enumerator.item();
		    var location = getComponent("WeatherLocation");
		    
		    // Get location id
		    location.ID = m_helper.GetNodeValue(entry, "@id/text()");	
		    
		    // Check the location type
		    var type = m_helper.GetNodeValue(entry, "@type/text()");	
		    
		    switch (type)
		    {
		    	// Type 1: City
		    	case "1":
		    		// We don't know the format of the location text, so we can't parse it
		    		// in particular, we have no idea if the second part is a state name or
		    		// a country
		    		location.Name = m_helper.GetNodeValue(entry, "text()");			    	
		    		break;
		    		
		    	// Type 4: 5-digits zip code		
		    	case "4":
		    		location.ZipCode = m_helper.GetNodeValue(entry, "text()");			
		    		break;
		    	
		    	// Unknown type
		    	default:
		    		// report with an error message
		    		m_errorCallback(ErrorCode.E_PARSERERROR, "Unknown location type: " + type);
		    		return;		    				    
		    }
		    
		    m_locations.Add(i, location);		    
		    i++;
		}
		
		// If we didn't get any location
		if (m_locations.Count == 0) {
			m_errorCallback(ErrorCode.E_ERROR, "No search results!");
			return;
		}
			
		m_locationsCallback(m_locations);
	}
	
	/////////////////////////////////////////////////////////////////////////////////////////////////////	
	// Get the current weather
	/////////////////////////////////////////////////////////////////////////////////////////////////////
	function GetWeather(locationQuery) {				
		// Check query for validity
		if (getQueryString(locationQuery, false) == "")
			return ErrorCode.E_NOTAVAILABLE;
					
		// Reset dom
		m_request.abort();
		
		// Check cache
		if (m_helper.CheckCache(m_weather, locationQuery.ID, getResource("refresh_weather"))) {
			m_weatherCallback(m_weather.Item(locationQuery.ID));
			
			return ErrorCode.E_OK;
		}

		m_request.onreadystatechange = OnWeatherResponse;
		m_request.async = true;
		m_request.load(getQueryString(locationQuery, false));
		
		return ErrorCode.E_OK;		
	}
	
	function OnWeatherResponse() {
		if (m_request.readyState != 4) 
			return;
			
		if (!m_helper.CheckParserError(m_request, m_errorCallback, ErrorCode))
			return;
			
		if (checkFeedError())
			return;
			
		var weather = getComponent("WeatherInfo");
		
		// Save update time
		weather.LastUpdateTime = m_dateHelper.GetDate();
		
		// Location
		var location = m_request.getElementsByTagName("loc");
		if (location.length != 0) {
			
			weather.Location = getComponent("WeatherLocation");
			
			weather.Location.ID 		= m_helper.GetNodeValue(location[0], "@id/text()");			
			weather.Location.Name  		= m_helper.GetNodeValue(location[0], "dnam/text()");		
			weather.Location.Latitude  	= m_helper.GetNodeValue(location[0], "lat/text()");		
			weather.Location.Longitude 	= m_helper.GetNodeValue(location[0], "lon/text()");			
			
			// TODO store the zone number
			// Use the "tm" value to adjust sunrise & sunset to local timezone
			
			// Sunrise & Sunset				
			weather.Sunrise 			= m_dateHelper.GetDate().parseExact(m_helper.GetNodeValue(location[0], "sunr/text()"), "h:mm tt");
			weather.Sunset 				= m_dateHelper.GetDate().parseExact(m_helper.GetNodeValue(location[0], "suns/text()"), "h:mm tt");			
		}
		
		// Weather data
		var info = m_request.getElementsByTagName("cc");
		if (info.length != 0) {
			
			// Remove end of date string if present
			var date = m_helper.GetNodeValue(info[0], "lsup/text()");
			var index = date.search("Local Time");
			if (index != -1)
				date = date.substr(0, index - 1); 
									
			weather.Date 				= m_dateHelper.GetDate().parseExact(date, ["d/mm/yy h:mm tt", "d/mm/yy h:mm tt zzz"]);				
			weather.Station				= m_helper.GetNodeValue(info[0], "obst/text()");
			weather.Temperature			= m_helper.GetNodeValue(info[0], "tmp/text()");
			weather.TemperatureFeel		= m_helper.GetNodeValue(info[0], "flik/text()");
			weather.Description			= m_helper.GetNodeValue(info[0], "t/text()");
			weather.Code				= parseCode(m_helper.GetNodeValue(info[0], "icon/text()"));
			
			weather.Pressure			= m_helper.GetNodeValue(info[0], "bar/r/text()");
			weather.PressureTrend		= m_helper.GetNodeValue(info[0], "bar/d/text()");
			
			weather.WindSpeed			= m_helper.GetNodeValue(info[0], "wind/s/text()");
			weather.WindGust			= m_helper.GetNodeValue(info[0], "wind/gust/text()");
			weather.WindDirection		= m_helper.GetNodeValue(info[0], "wind/d/text()");
			weather.WindDescription		= m_helper.GetNodeValue(info[0], "wind/t/text()");
			
			weather.Humidity			= m_helper.GetNodeValue(info[0], "hmid/text()");
			weather.Visibility			= m_helper.GetNodeValue(info[0], "vis/text()");
			
			weather.UV					= m_helper.GetNodeValue(info[0], "uv/i/text()");
			weather.UVDescription		= m_helper.GetNodeValue(info[0], "uv/t/text()");
			
			weather.DewPoint			= m_helper.GetNodeValue(info[0], "dewp/text()");
			
			weather.MoonPhaseCode		= parseCodeMoon(m_helper.GetNodeValue(info[0], "moon/icon/text()"));
			weather.MoonPhaseDescription = m_helper.GetNodeValue(info[0], "moon/t/text()");			
		}
		
		// Links
		weather.Links = parseLinks();
		
		// Update weather cache
		if (weather.Location.ID != null)
			m_weather(weather.Location.ID) = weather;
		 	
		m_weatherCallback(weather);	
	}
	
	/////////////////////////////////////////////////////////////////////////////////////////////////////	
	// Get the forecast
	/////////////////////////////////////////////////////////////////////////////////////////////////////
	function GetForecast(locationQuery) {		
		// Check query for validity
		if (getQueryString(locationQuery, true) == "")
			return ErrorCode.E_NOTAVAILABLE;
					
		// Reset dom
		m_request.abort();
		
		// Check cache
		if (m_helper.CheckCache(m_forecast, locationQuery.ID, getResource("refresh_forecast"))) {
			m_weatherCallback(m_forecast.Item(locationQuery.ID));
			
			return ErrorCode.E_OK;
		}

		m_request.onreadystatechange = OnForecastResponse;
		m_request.async = true;
		m_request.load(getQueryString(locationQuery, true));
		
		return ErrorCode.E_OK;		
	}
	
	function OnForecastResponse() {
		if (m_request.readyState != 4) 
			return;
			
		if (!m_helper.CheckParserError(m_request, m_errorCallback, ErrorCode))
			return;
		
		// TODO: Implementation
		
		//if (location.id != null)
		//	m_forecast(location.id) = forecast;
		
		m_forecastCallback(forecast);		
	}
	
	/////////////////////////////////////////////////////////////////////////////////////////////////////		
	// Get a list of alerts
	/////////////////////////////////////////////////////////////////////////////////////////////////////
	function GetAlerts(locationQuery) {
		return ErrorCode.E_NOTIMPLEMENTED;
	}
	
	/////////////////////////////////////////////////////////////////////////////////////////////////////	
	// Get a list of cameras
	/////////////////////////////////////////////////////////////////////////////////////////////////////
	function GetCameras(locationQuery) {		
		return ErrorCode.E_NOTIMPLEMENTED;
	}	
		
	]]>
	</script>

</component><component id="NOAA">
	<comment>
		NOAA Weather Provider
	</comment>
	<registration description="NOAA Weather Provider" progid="DXWeatherProvider.NOAA" version="1" classid="{7877D04D-AC0F-43c6-83F5-F511B9677230}" />  
      	    	  
      	    
	<object id="m_locations" progid="Scripting.Dictionary" />  
    <object id="m_alerts" progid="Scripting.Dictionary" />  
    <object id="m_forecast" progid="Scripting.Dictionary" />  

    <object id="m_request" progid="Microsoft.XmlDom" /> 
	    
	<public>
		<property name="ID">
			<get />
		</property>
	
		<property name="Name">
			<get />
		</property>
		
		<property name="UseMetricSystem" internalName="m_useMetricSystem" />
		
		<method name="SetLicense">
			<parameter name="id" />
			<parameter name="key" />
		</method>
		
		<method name="RegisterCallbacks">
			<parameter name="locationCallback" />
			<parameter name="weatherCallback" />
			<parameter name="alertsCallback" />
			<parameter name="forecastCallback" />
			<parameter name="camerasCallback" />
			<parameter name="errorCallback" />
		</method>
		
		<method name="Abort" />
		
		<comment>
			Query can be one of the following:
				- 
		</comment>
		<method name="GetLocations">
			<parameter name="locationQuery" />
		</method>

		<comment>
			Query can be one of the following:
				- 
		</comment>
		<method name="GetWeather">
			<parameter name="locationQuery" />
		</method>

		<comment>
			Query can be one of the following:
				-
		</comment>
		<method name="GetAlerts">
			<parameter name="locationQuery" />
		</method>

		<comment>
			Query can be one of the following:
				-
		</comment>
		<method name="GetForecast">
			<parameter name="locationQuery" />
		</method>
		
		<comment>
			Not supported by NOAA
		</comment>
		<method name="GetCameras">
			<parameter name="locationQuery" />
		</method>			
	
	</public>
	
	<resource id="provider_id">NOAA</resource>
	<resource id="provider_name">NOAA's National Weather</resource>
	<resource id="url_locations"></resource>
	<resource id="url_weather"></resource>
	<resource id="url_station"></resource>
	<resource id="url_alerts"></resource>
	<resource id="url_forecast"></resource>
	
	<script language="JScript">
	<![CDATA[
	
	//**Start Encode**
	
	var ErrorCode 			= getComponent("WeatherError");
	
	// Data
	var m_weather   		= null;
	var m_lastUpdateTime	= null;
	
	// Helper
	var m_helper			= getComponent("WeatherHelper");

	// callbacks
	var m_locationsCallback = null;
	var m_weatherCallback 	= null;
	var m_alertsCallback 	= null;
	var m_forecastCallback  = null;
	var m_camerasCallback   = null;
	var m_errorCallback 	= null;
	
	var m_useMetricSystem = true;
	
	///////////////////////////////
	// Utilities
	///////////////////////////////
	function getComponent(id) {		
		return createComponent(id);
	}
	
	function getQueryString(query)
	{
		return "";
	}
	
	///////////////////////////////
	// Properties
	///////////////////////////////
	function get_ID() {
		return getResource("provider_id");
	}
	
	function get_Name() {
		return getResource("provider_name");
	}
	
	///////////////////////////////
	// Public functions
	///////////////////////////////
	
	// Setup license
	function SetLicense(id, key) {	
		// Not used by this provider: always return E_OK
		return ErrorCode.E_OK;
	}
	
	// Set callbacks
	function RegisterCallbacks(locationsCallback, weatherCallback, alertsCallback, forecastCallback, camerasCallback, errorCallback) {
		m_locationsCallback = locationsCallback;
		m_weatherCallback 	= weatherCallback;
		m_alertsCallback 	= alertsCallback;
		m_forecastCallback  = forecastCallback;
		m_camerasCallback   = camerasCallback;
		m_errorCallback 	= errorCallback;
	}
	
	// Abort current request
	function Abort()
	{
		m_request.abort();
	}
	
	/////////////////////////////////////////////////////////////////////////////////////////////////////
	// Get a list of locations
	/////////////////////////////////////////////////////////////////////////////////////////////////////
	function GetLocations(locationQuery) {
		// Clear any previous results
		m_locations.RemoveAll();
		
		// Check query for validity
		if (getQueryString(locationQuery) == "")
			return ErrorCode.E_NOTAVAILABLE;
		
		// Reset dom
		m_request.abort();
		
		m_request.onreadystatechange = OnLocationsResponse;
		m_request.async = true;
		m_request.load(getResource("url_locations") + getQueryString(locationQuery));
		
		return ErrorCode.E_OK;		
	}
	
	function OnLocationsResponse() {
		if (m_request.readyState != 4) 
			return;
			
		if (!m_helper.CheckParserError(m_request, m_errorCallback, ErrorCode))
			return;
		
		// TODO: Implementation
		
		m_locationsCallback(m_locations);
	}
	
	/////////////////////////////////////////////////////////////////////////////////////////////////////	
	// Get the current weather
	/////////////////////////////////////////////////////////////////////////////////////////////////////
	function GetWeather(locationQuery) {
		
		// Reset weather object
		m_weather = null;
		m_weather = getComponent("WeatherInfo");
				
		// Check query for validity
		if (getQueryString(locationQuery) == "")
			return ErrorCode.E_NOTAVAILABLE;
					
		// Reset dom
		m_request.abort();
		
		m_request.onreadystatechange = OnWeatherResponse;
		m_request.async = true;
		m_request.load(getResource("url_weather") + getQueryString(locationQuery));
		
		return ErrorCode.E_OK;		
	}
	
	function OnWeatherResponse() {
		if (m_request.readyState != 4) 
			return;
			
		if (!m_helper.CheckParserError(m_request, m_errorCallback, ErrorCode))
			return;
			
		// TODO: Implementation
	    	
		m_weatherCallback(m_weather);	
	}

	/////////////////////////////////////////////////////////////////////////////////////////////////////		
	// Get a list of alerts
	/////////////////////////////////////////////////////////////////////////////////////////////////////
	function GetAlerts(locationQuery) {
		return ErrorCode.E_NOTIMPLEMENTED;
	}
	
	/////////////////////////////////////////////////////////////////////////////////////////////////////	
	// Get the forecast
	/////////////////////////////////////////////////////////////////////////////////////////////////////
	function GetForecast(locationQuery) {		
		// Clear any previous results
		m_forecast.RemoveAll();
		
		// Check query for validity
		if (getQueryString(locationQuery) == "")
			return ErrorCode.E_NOTAVAILABLE;
		
		// Reset dom
		m_request.abort();
		
		m_request.onreadystatechange = OnForecastResponse;
		m_request.async = true;
		m_request.load(getResource("url_forecast") + getQueryString(locationQuery));
		
		return ErrorCode.E_OK;	
	}
	
	function OnForecastResponse() {
		if (m_request.readyState != 4) 
			return;
			
		if (!m_helper.CheckParserError(m_request, m_errorCallback, ErrorCode))
			return;
		
		// TODO: Implementation
		
		m_forecastCallback(m_forecast);		
	}
	
	/////////////////////////////////////////////////////////////////////////////////////////////////////	
	// Get a list of cameras
	/////////////////////////////////////////////////////////////////////////////////////////////////////
	function GetCameras(locationQuery) {		
		return ErrorCode.E_NOTIMPLEMENTED;
	}	
		
	]]>
	</script>

</component>
</package>
